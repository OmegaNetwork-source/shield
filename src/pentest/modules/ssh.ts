// STRIX SSH Scanner Module
// Checks for SSH vulnerabilities and weak configurations

import * as net from 'net';
import { VulnerabilityResult, ModuleInfo, ModuleResult } from '../types';

export const moduleInfo: ModuleInfo = {
    name: 'ssh_scanner',
    displayName: 'SSH Scanner',
    description: 'Scans for SSH version, weak algorithms, and known vulnerabilities',
    author: 'STRIX',
    version: '1.0.0',
    type: 'vuln_check',
    targetService: 'ssh',
    options: [
        { name: 'target', type: 'string', required: true, description: 'Target IP address' },
        { name: 'port', type: 'number', required: false, default: 22, description: 'SSH port' },
        { name: 'timeout', type: 'number', required: false, default: 5000, description: 'Connection timeout' }
    ]
};

// Weak/deprecated algorithms
const WEAK_KEX = [
    'diffie-hellman-group1-sha1',
    'diffie-hellman-group14-sha1',
    'diffie-hellman-group-exchange-sha1'
];

const WEAK_CIPHERS = [
    '3des-cbc',
    'arcfour',
    'arcfour128',
    'arcfour256',
    'blowfish-cbc',
    'cast128-cbc',
    'aes128-cbc',
    'aes192-cbc',
    'aes256-cbc'
];

const WEAK_MACS = [
    'hmac-md5',
    'hmac-md5-96',
    'hmac-sha1-96',
    'umac-64@openssh.com'
];

// Known vulnerable SSH versions
const VULNERABLE_VERSIONS: { pattern: RegExp; vuln: string; severity: 'critical' | 'high' | 'medium' }[] = [
    { pattern: /OpenSSH[_-]([1-6]\.\d|7\.[0-1])/i, vuln: 'CVE-2016-10009', severity: 'high' },
    { pattern: /OpenSSH[_-]7\.2/i, vuln: 'CVE-2016-6515', severity: 'high' },
    { pattern: /libssh[_-]0\.[67]\./i, vuln: 'CVE-2018-10933', severity: 'critical' },
    { pattern: /Dropbear[_-]201[0-5]/i, vuln: 'Multiple CVEs', severity: 'high' },
];

export interface SSHInfo {
    version: string;
    software: string;
    protocol: string;
    banner: string;
    kexAlgorithms?: string[];
    ciphers?: string[];
    macs?: string[];
    hostKeyTypes?: string[];
}

export interface SSHScanResult extends ModuleResult {
    data: {
        info?: SSHInfo;
        weakAlgorithms?: string[];
    };
}

/**
 * Run SSH scan
 */
export async function run(
    target: string,
    options: { port?: number; timeout?: number } = {}
): Promise<SSHScanResult> {
    const port = options.port || 22;
    const timeout = options.timeout || 5000;
    const startTime = Date.now();
    
    const result: SSHScanResult = {
        success: false,
        module: 'ssh_scanner',
        target,
        data: {},
        vulnerabilities: [],
        duration: 0
    };
    
    try {
        const info = await getSSHInfo(target, port, timeout);
        
        if (info) {
            result.data.info = info;
            result.success = true;
            
            // Check for vulnerable versions
            for (const check of VULNERABLE_VERSIONS) {
                if (check.pattern.test(info.banner)) {
                    result.vulnerabilities!.push({
                        id: `SSH-VULN-${check.vuln}`,
                        name: `Vulnerable SSH Version (${check.vuln})`,
                        severity: check.severity,
                        description: `SSH software version is known to be vulnerable: ${info.software}`,
                        cve: check.vuln,
                        remediation: 'Update SSH software to the latest version.',
                        host: target,
                        port,
                        service: 'ssh'
                    });
                }
            }
            
            // Check for SSHv1 protocol support
            if (info.protocol.startsWith('1.')) {
                result.vulnerabilities!.push({
                    id: 'SSH-001',
                    name: 'SSH Protocol Version 1',
                    severity: 'critical',
                    description: 'SSH protocol version 1 is enabled. This protocol has known cryptographic weaknesses.',
                    remediation: 'Disable SSH protocol version 1 and use protocol version 2 only.',
                    host: target,
                    port,
                    service: 'ssh'
                });
            }
            
            // Check for weak algorithms (if we got algorithm info)
            const weakAlgos: string[] = [];
            
            if (info.kexAlgorithms) {
                for (const kex of info.kexAlgorithms) {
                    if (WEAK_KEX.some(w => kex.includes(w))) {
                        weakAlgos.push(`KEX: ${kex}`);
                    }
                }
            }
            
            if (info.ciphers) {
                for (const cipher of info.ciphers) {
                    if (WEAK_CIPHERS.some(w => cipher.includes(w))) {
                        weakAlgos.push(`Cipher: ${cipher}`);
                    }
                }
            }
            
            if (info.macs) {
                for (const mac of info.macs) {
                    if (WEAK_MACS.some(w => mac.includes(w))) {
                        weakAlgos.push(`MAC: ${mac}`);
                    }
                }
            }
            
            if (weakAlgos.length > 0) {
                result.data.weakAlgorithms = weakAlgos;
                result.vulnerabilities!.push({
                    id: 'SSH-002',
                    name: 'Weak SSH Algorithms',
                    severity: 'medium',
                    description: `Weak or deprecated algorithms are supported: ${weakAlgos.join(', ')}`,
                    remediation: 'Configure SSH to use only strong, modern algorithms.',
                    host: target,
                    port,
                    service: 'ssh'
                });
            }
            
            // Check for password authentication (info banner hint)
            if (info.banner.toLowerCase().includes('password')) {
                result.vulnerabilities!.push({
                    id: 'SSH-003',
                    name: 'Password Authentication Possibly Enabled',
                    severity: 'low',
                    description: 'SSH banner suggests password authentication may be enabled.',
                    remediation: 'Consider using key-based authentication only.',
                    host: target,
                    port,
                    service: 'ssh'
                });
            }
        }
        
    } catch (err: any) {
        result.error = err.message;
    }
    
    result.duration = Date.now() - startTime;
    return result;
}

/**
 * Get SSH banner and version info
 */
async function getSSHInfo(host: string, port: number, timeout: number): Promise<SSHInfo | null> {
    return new Promise((resolve) => {
        const socket = new net.Socket();
        socket.setTimeout(timeout);
        let banner = '';
        
        socket.on('connect', () => {
            // SSH server sends banner first, we just wait for it
        });
        
        socket.on('data', (data) => {
            banner += data.toString();
            
            if (banner.includes('\n')) {
                socket.destroy();
                
                const info = parseSSHBanner(banner);
                resolve(info);
            }
        });
        
        socket.on('timeout', () => {
            socket.destroy();
            if (banner) {
                resolve(parseSSHBanner(banner));
            } else {
                resolve(null);
            }
        });
        
        socket.on('error', () => {
            socket.destroy();
            resolve(null);
        });
        
        socket.connect(port, host);
    });
}

/**
 * Parse SSH banner
 */
function parseSSHBanner(banner: string): SSHInfo | null {
    // SSH banner format: SSH-protoversion-softwareversion [comments]
    const match = banner.match(/SSH-(\d+\.\d+)-([^\s\r\n]+)/);
    
    if (!match) return null;
    
    const [, protocol, software] = match;
    
    // Extract version number from software string
    const versionMatch = software.match(/(\d+\.\d+(?:\.\d+)?(?:p\d+)?)/);
    const version = versionMatch ? versionMatch[1] : software;
    
    return {
        version,
        software,
        protocol,
        banner: banner.trim()
    };
}

export default { run, moduleInfo, getSSHInfo };
