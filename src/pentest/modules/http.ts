// STRIX HTTP Scanner Module  
// Checks for HTTP/HTTPS vulnerabilities and misconfigurations

import * as http from 'http';
import * as https from 'https';
import * as tls from 'tls';
import { VulnerabilityResult, ModuleInfo, ModuleResult } from '../types';

export const moduleInfo: ModuleInfo = {
    name: 'http_scanner',
    displayName: 'HTTP/HTTPS Scanner',
    description: 'Scans for web server vulnerabilities, security headers, and SSL/TLS issues',
    author: 'STRIX',
    version: '1.0.0',
    type: 'vuln_check',
    targetService: 'http',
    options: [
        { name: 'target', type: 'string', required: true, description: 'Target IP or hostname' },
        { name: 'port', type: 'number', required: false, default: 80, description: 'HTTP port' },
        { name: 'ssl', type: 'boolean', required: false, default: false, description: 'Use HTTPS' },
        { name: 'timeout', type: 'number', required: false, default: 10000, description: 'Request timeout' }
    ]
};

// Security headers to check
const SECURITY_HEADERS = [
    { name: 'Strict-Transport-Security', required: true, severity: 'medium' as const },
    { name: 'X-Content-Type-Options', required: true, severity: 'low' as const },
    { name: 'X-Frame-Options', required: true, severity: 'medium' as const },
    { name: 'Content-Security-Policy', required: false, severity: 'medium' as const },
    { name: 'X-XSS-Protection', required: false, severity: 'low' as const },
    { name: 'Referrer-Policy', required: false, severity: 'low' as const },
    { name: 'Permissions-Policy', required: false, severity: 'low' as const },
];

// Dangerous HTTP methods
const DANGEROUS_METHODS = ['PUT', 'DELETE', 'TRACE', 'CONNECT'];

// Weak TLS versions
const WEAK_TLS = ['TLSv1', 'TLSv1.1', 'SSLv3', 'SSLv2'];

// Weak cipher suites patterns
const WEAK_CIPHERS = [
    /RC4/i,
    /DES/i,
    /MD5/i,
    /NULL/i,
    /EXPORT/i,
    /anon/i,
    /CBC/i  // CBC mode has vulnerabilities
];

export interface HTTPInfo {
    server?: string;
    poweredBy?: string;
    title?: string;
    statusCode: number;
    headers: { [key: string]: string };
    methods?: string[];
    redirects?: string[];
}

export interface TLSInfo {
    protocol: string;
    cipher: string;
    certIssuer?: string;
    certSubject?: string;
    certExpiry?: Date;
    certValid: boolean;
}

export interface HTTPScanResult extends ModuleResult {
    data: {
        http?: HTTPInfo;
        tls?: TLSInfo;
        missingHeaders?: string[];
        dangerousMethods?: string[];
    };
}

/**
 * Run HTTP scan
 */
export async function run(
    target: string,
    options: { port?: number; ssl?: boolean; timeout?: number } = {}
): Promise<HTTPScanResult> {
    const port = options.port || (options.ssl ? 443 : 80);
    const ssl = options.ssl ?? (port === 443 || port === 8443);
    const timeout = options.timeout || 10000;
    const startTime = Date.now();

    const result: HTTPScanResult = {
        success: false,
        module: 'http_scanner',
        target,
        data: {},
        vulnerabilities: [],
        duration: 0
    };

    try {
        // Get HTTP info
        const httpInfo = await getHTTPInfo(target, port, ssl, timeout);

        if (httpInfo) {
            result.data.http = httpInfo;
            result.success = true;

            // Check for server header disclosure
            if (httpInfo.server) {
                result.vulnerabilities!.push({
                    id: 'HTTP-001',
                    name: 'Server Version Disclosure',
                    severity: 'info',
                    description: `Server header reveals: ${httpInfo.server}`,
                    evidence: `Server: ${httpInfo.server}`,
                    remediation: 'Configure the web server to hide or minimize version information.',
                    host: target,
                    port,
                    service: ssl ? 'https' : 'http'
                });
            }

            // Check X-Powered-By header
            if (httpInfo.poweredBy) {
                result.vulnerabilities!.push({
                    id: 'HTTP-002',
                    name: 'Technology Stack Disclosure',
                    severity: 'low',
                    description: `X-Powered-By header reveals: ${httpInfo.poweredBy}`,
                    evidence: `X-Powered-By: ${httpInfo.poweredBy}`,
                    remediation: 'Remove or hide the X-Powered-By header.',
                    host: target,
                    port,
                    service: ssl ? 'https' : 'http'
                });
            }

            // Check for missing security headers
            const missingHeaders: string[] = [];
            for (const header of SECURITY_HEADERS) {
                const headerLower = header.name.toLowerCase();
                const hasHeader = Object.keys(httpInfo.headers).some(
                    h => h.toLowerCase() === headerLower
                );

                if (!hasHeader && header.required) {
                    missingHeaders.push(header.name);
                }
            }

            if (missingHeaders.length > 0) {
                result.data.missingHeaders = missingHeaders;
                result.vulnerabilities!.push({
                    id: 'HTTP-003',
                    name: 'Missing Security Headers',
                    severity: 'medium',
                    description: `Missing security headers: ${missingHeaders.join(', ')}`,
                    remediation: 'Configure the web server to include security headers.',
                    host: target,
                    port,
                    service: ssl ? 'https' : 'http'
                });
            }

            // Check for HTTPS redirect on HTTP
            if (!ssl && port === 80) {
                const redirectsToHTTPS = httpInfo.redirects?.some(r => r.startsWith('https://'));
                if (!redirectsToHTTPS) {
                    result.vulnerabilities!.push({
                        id: 'HTTP-004',
                        name: 'No HTTPS Redirect',
                        severity: 'medium',
                        description: 'HTTP does not redirect to HTTPS',
                        remediation: 'Configure automatic redirect from HTTP to HTTPS.',
                        host: target,
                        port,
                        service: 'http'
                    });
                }
            }
        }

        // Check dangerous HTTP methods
        const methods = await checkHTTPMethods(target, port, ssl, timeout);
        if (methods && methods.length > 0) {
            const dangerous = methods.filter(m => DANGEROUS_METHODS.includes(m.toUpperCase()));
            if (dangerous.length > 0) {
                result.data.dangerousMethods = dangerous;
                result.vulnerabilities!.push({
                    id: 'HTTP-005',
                    name: 'Dangerous HTTP Methods Enabled',
                    severity: 'medium',
                    description: `Potentially dangerous HTTP methods enabled: ${dangerous.join(', ')}`,
                    remediation: 'Disable unnecessary HTTP methods.',
                    host: target,
                    port,
                    service: ssl ? 'https' : 'http'
                });
            }
        }

        // Check TLS if using SSL
        if (ssl) {
            const tlsInfo = await getTLSInfo(target, port, timeout);
            if (tlsInfo) {
                result.data.tls = tlsInfo;

                // Check for weak TLS version
                if (WEAK_TLS.some(v => tlsInfo.protocol.includes(v))) {
                    result.vulnerabilities!.push({
                        id: 'TLS-001',
                        name: 'Weak TLS Version',
                        severity: 'high',
                        description: `Weak TLS version in use: ${tlsInfo.protocol}`,
                        remediation: 'Upgrade to TLS 1.2 or higher.',
                        host: target,
                        port,
                        service: 'https'
                    });
                }

                // Check for weak cipher
                if (WEAK_CIPHERS.some(pattern => pattern.test(tlsInfo.cipher))) {
                    result.vulnerabilities!.push({
                        id: 'TLS-002',
                        name: 'Weak Cipher Suite',
                        severity: 'medium',
                        description: `Weak cipher suite: ${tlsInfo.cipher}`,
                        remediation: 'Configure server to use only strong cipher suites.',
                        host: target,
                        port,
                        service: 'https'
                    });
                }

                // Check certificate validity
                if (!tlsInfo.certValid) {
                    result.vulnerabilities!.push({
                        id: 'TLS-003',
                        name: 'Invalid SSL Certificate',
                        severity: 'high',
                        description: 'SSL certificate is invalid or not trusted',
                        remediation: 'Obtain a valid SSL certificate from a trusted CA.',
                        host: target,
                        port,
                        service: 'https'
                    });
                }

                // Check certificate expiry
                if (tlsInfo.certExpiry) {
                    const daysUntilExpiry = Math.floor(
                        (tlsInfo.certExpiry.getTime() - Date.now()) / (1000 * 60 * 60 * 24)
                    );

                    if (daysUntilExpiry < 0) {
                        result.vulnerabilities!.push({
                            id: 'TLS-004',
                            name: 'Expired SSL Certificate',
                            severity: 'critical',
                            description: 'SSL certificate has expired',
                            remediation: 'Renew the SSL certificate immediately.',
                            host: target,
                            port,
                            service: 'https'
                        });
                    } else if (daysUntilExpiry < 30) {
                        result.vulnerabilities!.push({
                            id: 'TLS-005',
                            name: 'SSL Certificate Expiring Soon',
                            severity: 'medium',
                            description: `SSL certificate expires in ${daysUntilExpiry} days`,
                            remediation: 'Renew the SSL certificate before expiration.',
                            host: target,
                            port,
                            service: 'https'
                        });
                    }
                }
            }
        }

    } catch (err: any) {
        result.error = err.message;
    }

    result.duration = Date.now() - startTime;
    return result;
}

/**
 * Get HTTP response info
 */
async function getHTTPInfo(
    host: string,
    port: number,
    ssl: boolean,
    timeout: number
): Promise<HTTPInfo | null> {
    return new Promise((resolve) => {
        const options = {
            hostname: host,
            port,
            path: '/',
            method: 'GET',
            timeout,
            rejectUnauthorized: false,
            headers: {
                'User-Agent': 'STRIX-Scanner/1.0',
                'Accept': '*/*'
            }
        };

        const protocol = ssl ? https : http;

        const req = protocol.request(options, (res) => {
            let body = '';

            res.on('data', (chunk) => {
                body += chunk;
                if (body.length > 10000) {
                    // Limit response size
                    res.destroy();
                }
            });

            res.on('end', () => {
                const headers: { [key: string]: string } = {};
                for (const [key, value] of Object.entries(res.headers)) {
                    if (typeof value === 'string') {
                        headers[key] = value;
                    } else if (Array.isArray(value)) {
                        headers[key] = value.join(', ');
                    }
                }

                // Extract title from HTML
                let title: string | undefined;
                const titleMatch = body.match(/<title[^>]*>([^<]+)<\/title>/i);
                if (titleMatch) {
                    title = titleMatch[1].trim();
                }

                // Track redirects
                const redirects: string[] = [];
                if (res.headers.location) {
                    redirects.push(res.headers.location);
                }

                resolve({
                    statusCode: res.statusCode || 0,
                    server: Array.isArray(res.headers.server) ? res.headers.server.join(', ') : res.headers.server,
                    poweredBy: Array.isArray(res.headers['x-powered-by']) ? res.headers['x-powered-by'].join(', ') : res.headers['x-powered-by'],
                    title,
                    headers,
                    redirects
                });
            });
        });

        req.on('timeout', () => {
            req.destroy();
            resolve(null);
        });

        req.on('error', () => {
            resolve(null);
        });

        req.end();
    });
}

/**
 * Check allowed HTTP methods using OPTIONS
 */
async function checkHTTPMethods(
    host: string,
    port: number,
    ssl: boolean,
    timeout: number
): Promise<string[] | null> {
    return new Promise((resolve) => {
        const options = {
            hostname: host,
            port,
            path: '/',
            method: 'OPTIONS',
            timeout,
            rejectUnauthorized: false
        };

        const protocol = ssl ? https : http;

        const req = protocol.request(options, (res) => {
            const allow = res.headers.allow || res.headers['access-control-allow-methods'];
            if (allow) {
                const allowStr = Array.isArray(allow) ? allow.join(',') : allow;
                resolve(allowStr.split(',').map(m => m.trim()));
            } else {
                resolve(null);
            }
        });

        req.on('timeout', () => {
            req.destroy();
            resolve(null);
        });

        req.on('error', () => {
            resolve(null);
        });

        req.end();
    });
}

/**
 * Get TLS/SSL certificate info
 */
async function getTLSInfo(host: string, port: number, timeout: number): Promise<TLSInfo | null> {
    return new Promise((resolve) => {
        const socket = tls.connect({
            host,
            port,
            timeout,
            rejectUnauthorized: false,
            servername: host
        }, () => {
            const cipher = socket.getCipher();
            const cert = socket.getPeerCertificate();
            const protocol = socket.getProtocol();

            const info: TLSInfo = {
                protocol: protocol || 'unknown',
                cipher: cipher ? cipher.name : 'unknown',
                certValid: socket.authorized
            };

            if (cert && Object.keys(cert).length > 0) {
                info.certSubject = cert.subject?.CN;
                info.certIssuer = cert.issuer?.CN;
                if (cert.valid_to) {
                    info.certExpiry = new Date(cert.valid_to);
                }
            }

            socket.destroy();
            resolve(info);
        });

        socket.on('timeout', () => {
            socket.destroy();
            resolve(null);
        });

        socket.on('error', () => {
            socket.destroy();
            resolve(null);
        });
    });
}

export default { run, moduleInfo, getHTTPInfo, getTLSInfo };
