// STRIX SMB Scanner Module
// Checks for SMB vulnerabilities and misconfigurations

import * as net from 'net';
import { VulnerabilityResult, ModuleInfo, ModuleResult } from '../types';

export const moduleInfo: ModuleInfo = {
    name: 'smb_scanner',
    displayName: 'SMB Scanner',
    description: 'Scans for SMB vulnerabilities including MS17-010 (EternalBlue), anonymous access, and version detection',
    author: 'STRIX',
    version: '1.0.0',
    type: 'vuln_check',
    targetService: 'smb',
    options: [
        { name: 'target', type: 'string', required: true, description: 'Target IP address' },
        { name: 'port', type: 'number', required: false, default: 445, description: 'SMB port' },
        { name: 'timeout', type: 'number', required: false, default: 5000, description: 'Connection timeout' }
    ]
};

// SMB Protocol Constants
const SMB_HEADER = Buffer.from([
    0x00, 0x00, 0x00, 0x00,  // NetBIOS Session Service (length filled later)
    0xff, 0x53, 0x4d, 0x42,  // SMB magic: \xffSMB
]);

const SMB2_HEADER = Buffer.from([
    0x00, 0x00, 0x00, 0x00,  // NetBIOS Session Service
    0xfe, 0x53, 0x4d, 0x42,  // SMB2 magic: \xfeSMB
]);

// SMB Negotiate Request (SMBv1)
const SMB_NEGOTIATE_REQUEST = Buffer.from([
    0x00, 0x00, 0x00, 0x85,  // NetBIOS length
    0xff, 0x53, 0x4d, 0x42,  // SMB magic
    0x72,                    // Command: Negotiate
    0x00, 0x00, 0x00, 0x00,  // Status
    0x18,                    // Flags
    0x53, 0xc8,              // Flags2
    0x00, 0x00,              // PID High
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Signature
    0x00, 0x00,              // Reserved
    0x00, 0x00,              // Tree ID
    0xff, 0xfe,              // Process ID
    0x00, 0x00,              // User ID
    0x00, 0x00,              // Multiplex ID
    // Negotiate Request
    0x00,                    // Word Count
    0x62, 0x00,              // Byte Count
    0x02, 0x50, 0x43, 0x20, 0x4e, 0x45, 0x54, 0x57, 0x4f, 0x52, 0x4b, 0x20, 0x50, 0x52, 0x4f, 0x47,
    0x52, 0x41, 0x4d, 0x20, 0x31, 0x2e, 0x30, 0x00,  // PC NETWORK PROGRAM 1.0
    0x02, 0x4c, 0x41, 0x4e, 0x4d, 0x41, 0x4e, 0x31, 0x2e, 0x30, 0x00,  // LANMAN1.0
    0x02, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x57, 0x6f, 0x72,
    0x6b, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x20, 0x33, 0x2e, 0x31, 0x61, 0x00,  // Windows for Workgroups 3.1a
    0x02, 0x4c, 0x4d, 0x31, 0x2e, 0x32, 0x58, 0x30, 0x30, 0x32, 0x00,  // LM1.2X002
    0x02, 0x4c, 0x41, 0x4e, 0x4d, 0x41, 0x4e, 0x32, 0x2e, 0x31, 0x00,  // LANMAN2.1
    0x02, 0x4e, 0x54, 0x20, 0x4c, 0x4d, 0x20, 0x30, 0x2e, 0x31, 0x32, 0x00  // NT LM 0.12
]);

// MS17-010 Check packet (Trans2 request)
const MS17010_CHECK = Buffer.from([
    0x00, 0x00, 0x00, 0x4a,  // NetBIOS length
    0xff, 0x53, 0x4d, 0x42,  // SMB magic
    0x25,                    // Command: Trans2
    0x00, 0x00, 0x00, 0x00,  // Status
    0x18,                    // Flags
    0x01, 0x28,              // Flags2
    0x00, 0x00,              // PID High
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Signature
    0x00, 0x00,              // Reserved
    0x00, 0x00,              // Tree ID
    0xff, 0xfe,              // Process ID
    0x00, 0x00,              // User ID
    0x40, 0x00,              // Multiplex ID
    // Trans2 parameters
    0x0f,                    // Word Count
    0x00, 0x00,              // Total Parameter Count
    0x00, 0x00,              // Total Data Count
    0x00, 0x00,              // Max Parameter Count
    0x00, 0x04,              // Max Data Count
    0x00,                    // Max Setup Count
    0x00,                    // Reserved
    0x00, 0x00,              // Flags
    0x00, 0x00, 0x00, 0x00,  // Timeout
    0x00, 0x00,              // Reserved
    0x00, 0x00,              // Parameter Count
    0x4a, 0x00,              // Parameter Offset
    0x00, 0x00,              // Data Count
    0x4a, 0x00,              // Data Offset
    0x02,                    // Setup Count
    0x00,                    // Reserved
    0x23, 0x00,              // TRANS2_SESSION_SETUP
    0x00, 0x00,              // Byte Count
    0x07, 0x00
]);

export interface SMBInfo {
    version: string;
    dialect: string;
    signing: boolean;
    signingRequired: boolean;
    os?: string;
    serverName?: string;
    domain?: string;
    capabilities?: string[];
}

export interface SMBScanResult extends ModuleResult {
    data: {
        info?: SMBInfo;
        anonymousAccess?: boolean;
        ms17010Vulnerable?: boolean;
        smbv1Enabled?: boolean;
    };
}

/**
 * Run full SMB scan
 */
export async function run(
    target: string,
    options: { port?: number; timeout?: number } = {}
): Promise<SMBScanResult> {
    const port = options.port || 445;
    const timeout = options.timeout || 5000;
    const startTime = Date.now();
    
    const result: SMBScanResult = {
        success: false,
        module: 'smb_scanner',
        target,
        data: {},
        vulnerabilities: [],
        duration: 0
    };
    
    try {
        // Get SMB version info
        const info = await getSMBInfo(target, port, timeout);
        if (info) {
            result.data.info = info;
            result.success = true;
            
            // Check for SMBv1
            if (info.dialect.includes('NT LM') || info.version === '1') {
                result.data.smbv1Enabled = true;
                result.vulnerabilities!.push({
                    id: 'SMB-001',
                    name: 'SMBv1 Enabled',
                    severity: 'high',
                    description: 'SMBv1 is enabled on this host. SMBv1 is deprecated and has known security vulnerabilities.',
                    remediation: 'Disable SMBv1 and use SMBv2 or SMBv3 instead.',
                    host: target,
                    port,
                    service: 'smb'
                });
            }
            
            // Check signing
            if (!info.signingRequired) {
                result.vulnerabilities!.push({
                    id: 'SMB-002',
                    name: 'SMB Signing Not Required',
                    severity: 'medium',
                    description: 'SMB signing is not required, making the host vulnerable to man-in-the-middle attacks.',
                    remediation: 'Enable required SMB signing in Group Policy.',
                    host: target,
                    port,
                    service: 'smb'
                });
            }
        }
        
        // Check for MS17-010 (EternalBlue)
        const ms17010 = await checkMS17010(target, port, timeout);
        if (ms17010) {
            result.data.ms17010Vulnerable = true;
            result.vulnerabilities!.push({
                id: 'SMB-003',
                name: 'MS17-010 (EternalBlue)',
                severity: 'critical',
                description: 'Host is vulnerable to MS17-010 (EternalBlue/WannaCry). This allows remote code execution.',
                cve: 'CVE-2017-0144',
                cvss: 9.8,
                remediation: 'Apply Microsoft security update MS17-010 immediately.',
                host: target,
                port,
                service: 'smb'
            });
        }
        
        // Check anonymous access
        const anon = await checkAnonymousAccess(target, port, timeout);
        if (anon) {
            result.data.anonymousAccess = true;
            result.vulnerabilities!.push({
                id: 'SMB-004',
                name: 'Anonymous SMB Access',
                severity: 'medium',
                description: 'Anonymous/guest access is allowed to SMB shares.',
                remediation: 'Disable anonymous access to SMB shares.',
                host: target,
                port,
                service: 'smb'
            });
        }
        
    } catch (err: any) {
        result.error = err.message;
    }
    
    result.duration = Date.now() - startTime;
    return result;
}

/**
 * Get SMB version and configuration info
 */
async function getSMBInfo(host: string, port: number, timeout: number): Promise<SMBInfo | null> {
    return new Promise((resolve) => {
        const socket = new net.Socket();
        socket.setTimeout(timeout);
        
        socket.on('connect', () => {
            socket.write(SMB_NEGOTIATE_REQUEST);
        });
        
        socket.on('data', (data) => {
            try {
                const info = parseSMBNegotiateResponse(data);
                socket.destroy();
                resolve(info);
            } catch {
                socket.destroy();
                resolve(null);
            }
        });
        
        socket.on('timeout', () => {
            socket.destroy();
            resolve(null);
        });
        
        socket.on('error', () => {
            socket.destroy();
            resolve(null);
        });
        
        socket.connect(port, host);
    });
}

/**
 * Check for MS17-010 vulnerability
 */
async function checkMS17010(host: string, port: number, timeout: number): Promise<boolean> {
    return new Promise((resolve) => {
        const socket = new net.Socket();
        socket.setTimeout(timeout);
        let negotiated = false;
        
        socket.on('connect', () => {
            socket.write(SMB_NEGOTIATE_REQUEST);
        });
        
        socket.on('data', (data) => {
            if (!negotiated) {
                negotiated = true;
                // Send MS17-010 check packet
                socket.write(MS17010_CHECK);
            } else {
                // Check response for vulnerability indicator
                // Vulnerable systems respond with STATUS_INSUFF_SERVER_RESOURCES (0xC0000205)
                // or don't properly handle the malformed request
                const status = data.readUInt32LE(9);
                socket.destroy();
                
                // Multiple indicators of vulnerability
                if (status === 0xC0000205 || status === 0xC0000022 || status === 0x00000000) {
                    resolve(true);
                } else {
                    resolve(false);
                }
            }
        });
        
        socket.on('timeout', () => {
            socket.destroy();
            resolve(false);
        });
        
        socket.on('error', () => {
            socket.destroy();
            resolve(false);
        });
        
        socket.connect(port, host);
    });
}

/**
 * Check for anonymous/guest access
 */
async function checkAnonymousAccess(host: string, port: number, timeout: number): Promise<boolean> {
    // This would require a full SMB session setup with null credentials
    // Simplified check - just attempt connection
    return new Promise((resolve) => {
        const socket = new net.Socket();
        socket.setTimeout(timeout);
        
        socket.on('connect', () => {
            // For now, just check if we can connect
            // Full implementation would do a null session setup
            socket.destroy();
            resolve(false); // Conservative - don't report false positives
        });
        
        socket.on('error', () => {
            socket.destroy();
            resolve(false);
        });
        
        socket.on('timeout', () => {
            socket.destroy();
            resolve(false);
        });
        
        socket.connect(port, host);
    });
}

/**
 * Parse SMB Negotiate response
 */
function parseSMBNegotiateResponse(data: Buffer): SMBInfo | null {
    if (data.length < 40) return null;
    
    // Check for SMB magic
    const magic = data.slice(4, 8).toString();
    
    if (magic === '\xffSMB') {
        // SMBv1 response
        const flags2 = data.readUInt16LE(14);
        const securityMode = data.length > 39 ? data.readUInt8(39) : 0;
        
        return {
            version: '1',
            dialect: 'NT LM 0.12',
            signing: (securityMode & 0x02) !== 0,
            signingRequired: (securityMode & 0x04) !== 0,
            capabilities: []
        };
    } else if (magic === '\xfeSMB') {
        // SMBv2/3 response
        const dialectRevision = data.readUInt16LE(72);
        const securityMode = data.readUInt16LE(74);
        
        let version = '2';
        let dialect = 'SMB 2.0';
        
        if (dialectRevision >= 0x0311) {
            version = '3.1.1';
            dialect = 'SMB 3.1.1';
        } else if (dialectRevision >= 0x0302) {
            version = '3.0.2';
            dialect = 'SMB 3.0.2';
        } else if (dialectRevision >= 0x0300) {
            version = '3.0';
            dialect = 'SMB 3.0';
        } else if (dialectRevision >= 0x0210) {
            version = '2.1';
            dialect = 'SMB 2.1';
        }
        
        return {
            version,
            dialect,
            signing: (securityMode & 0x01) !== 0,
            signingRequired: (securityMode & 0x02) !== 0,
            capabilities: []
        };
    }
    
    return null;
}

export default { run, moduleInfo, getSMBInfo, checkMS17010 };
