// STRIX Security Headers Analyzer Module
// Comprehensive security headers checker (CSP, HSTS, X-Frame-Options, etc.)

import * as http from 'http';
import * as https from 'https';
import { VulnerabilityResult, ModuleInfo, ModuleResult } from '../types';

export const moduleInfo: ModuleInfo = {
    name: 'headers_analyzer',
    displayName: 'Security Headers Analyzer',
    description: 'Analyzes HTTP security headers for misconfigurations and missing protections',
    author: 'STRIX',
    version: '1.0.0',
    type: 'vuln_check',
    targetService: 'http',
    options: [
        { name: 'target', type: 'string', required: true, description: 'Target URL' },
        { name: 'timeout', type: 'number', required: false, default: 10000, description: 'Request timeout' },
        { name: 'followRedirects', type: 'boolean', required: false, default: true, description: 'Follow redirects' }
    ]
};

// Security header definitions with best practices
const SECURITY_HEADERS = {
    'Strict-Transport-Security': {
        required: true,
        severity: 'high' as const,
        description: 'HSTS - Forces HTTPS connections',
        recommendation: 'Set Strict-Transport-Security: max-age=31536000; includeSubDomains; preload',
        validate: (value: string) => {
            const issues: string[] = [];
            if (!value.includes('max-age=')) {
                issues.push('Missing max-age directive');
            } else {
                const maxAge = parseInt(value.match(/max-age=(\d+)/)?.[1] || '0');
                if (maxAge < 31536000) {
                    issues.push(`max-age too short (${maxAge}s), should be at least 31536000 (1 year)`);
                }
            }
            if (!value.includes('includeSubDomains')) {
                issues.push('Missing includeSubDomains directive (recommended)');
            }
            return issues;
        }
    },
    
    'Content-Security-Policy': {
        required: true,
        severity: 'high' as const,
        description: 'CSP - Prevents XSS and injection attacks',
        recommendation: "Implement a strict Content-Security-Policy. Start with: default-src 'self'; script-src 'self'; style-src 'self'",
        validate: (value: string) => {
            const issues: string[] = [];
            if (value.includes("'unsafe-inline'")) {
                issues.push("Uses 'unsafe-inline' which weakens XSS protection");
            }
            if (value.includes("'unsafe-eval'")) {
                issues.push("Uses 'unsafe-eval' which allows eval() and similar");
            }
            if (value.includes('*') && !value.includes('*.')) {
                issues.push("Uses wildcard (*) source which is too permissive");
            }
            if (!value.includes('default-src')) {
                issues.push('Missing default-src directive');
            }
            if (value.includes('data:') && value.includes('script-src')) {
                issues.push("'data:' in script-src can allow XSS");
            }
            return issues;
        }
    },
    
    'X-Content-Type-Options': {
        required: true,
        severity: 'medium' as const,
        description: 'Prevents MIME type sniffing',
        recommendation: 'Set X-Content-Type-Options: nosniff',
        validate: (value: string) => {
            if (value.toLowerCase() !== 'nosniff') {
                return ['Should be set to "nosniff"'];
            }
            return [];
        }
    },
    
    'X-Frame-Options': {
        required: true,
        severity: 'medium' as const,
        description: 'Prevents clickjacking attacks',
        recommendation: 'Set X-Frame-Options: DENY or SAMEORIGIN',
        validate: (value: string) => {
            const upper = value.toUpperCase();
            if (!['DENY', 'SAMEORIGIN'].includes(upper) && !upper.startsWith('ALLOW-FROM')) {
                return ['Should be DENY, SAMEORIGIN, or ALLOW-FROM uri'];
            }
            if (upper.startsWith('ALLOW-FROM')) {
                return ['ALLOW-FROM is deprecated and not supported by modern browsers'];
            }
            return [];
        }
    },
    
    'X-XSS-Protection': {
        required: false,
        severity: 'low' as const,
        description: 'Legacy XSS filter (deprecated but still useful for older browsers)',
        recommendation: 'Set X-XSS-Protection: 1; mode=block (or 0 if you have strong CSP)',
        validate: (value: string) => {
            if (value === '0') {
                return []; // Explicitly disabled is fine if CSP is strong
            }
            if (!value.includes('mode=block')) {
                return ['Should include mode=block'];
            }
            return [];
        }
    },
    
    'Referrer-Policy': {
        required: true,
        severity: 'medium' as const,
        description: 'Controls referrer information sent with requests',
        recommendation: 'Set Referrer-Policy: strict-origin-when-cross-origin or no-referrer',
        validate: (value: string) => {
            const safe = [
                'no-referrer',
                'no-referrer-when-downgrade',
                'same-origin',
                'origin',
                'strict-origin',
                'origin-when-cross-origin',
                'strict-origin-when-cross-origin'
            ];
            if (!safe.includes(value.toLowerCase())) {
                return [`"${value}" may leak sensitive URL information`];
            }
            if (value.toLowerCase() === 'unsafe-url') {
                return ['unsafe-url leaks full URL in referrer'];
            }
            return [];
        }
    },
    
    'Permissions-Policy': {
        required: false,
        severity: 'low' as const,
        description: 'Controls browser features and APIs',
        recommendation: 'Set Permissions-Policy to disable unused features: camera=(), microphone=(), geolocation=()',
        validate: (value: string) => {
            const issues: string[] = [];
            // Check for overly permissive settings
            if (value.includes('*')) {
                issues.push('Wildcard (*) allows all origins for some features');
            }
            return issues;
        }
    },
    
    'Cross-Origin-Opener-Policy': {
        required: false,
        severity: 'medium' as const,
        description: 'COOP - Isolates browsing context',
        recommendation: 'Set Cross-Origin-Opener-Policy: same-origin',
        validate: (value: string) => {
            if (!['same-origin', 'same-origin-allow-popups', 'unsafe-none'].includes(value.toLowerCase())) {
                return ['Invalid value'];
            }
            return [];
        }
    },
    
    'Cross-Origin-Embedder-Policy': {
        required: false,
        severity: 'medium' as const,
        description: 'COEP - Prevents loading cross-origin resources',
        recommendation: 'Set Cross-Origin-Embedder-Policy: require-corp',
        validate: () => []
    },
    
    'Cross-Origin-Resource-Policy': {
        required: false,
        severity: 'medium' as const,
        description: 'CORP - Protects resources from cross-origin access',
        recommendation: 'Set Cross-Origin-Resource-Policy: same-origin or same-site',
        validate: () => []
    }
};

// Headers that should NOT be present (information disclosure)
const DANGEROUS_HEADERS = {
    'Server': {
        severity: 'info' as const,
        description: 'Server version disclosure',
        check: (value: string) => {
            // Check if it contains version information
            if (/\d+\.\d+/.test(value)) {
                return `Reveals server version: ${value}`;
            }
            return null;
        }
    },
    'X-Powered-By': {
        severity: 'low' as const,
        description: 'Technology stack disclosure',
        check: (value: string) => `Reveals technology: ${value}`
    },
    'X-AspNet-Version': {
        severity: 'low' as const,
        description: 'ASP.NET version disclosure',
        check: (value: string) => `Reveals ASP.NET version: ${value}`
    },
    'X-AspNetMvc-Version': {
        severity: 'low' as const,
        description: 'ASP.NET MVC version disclosure',
        check: (value: string) => `Reveals ASP.NET MVC version: ${value}`
    },
    'X-Generator': {
        severity: 'info' as const,
        description: 'Generator/CMS disclosure',
        check: (value: string) => `Reveals generator: ${value}`
    },
    'X-Drupal-Cache': {
        severity: 'info' as const,
        description: 'Drupal CMS detection',
        check: () => 'Site is running Drupal'
    }
};

export interface HeaderInfo {
    name: string;
    value: string | null;
    present: boolean;
    required: boolean;
    issues: string[];
    recommendation: string;
}

export interface HeadersScanResult extends ModuleResult {
    data: {
        url: string;
        statusCode: number;
        headers: { [key: string]: string };
        securityHeaders: HeaderInfo[];
        missingRequired: string[];
        informationDisclosure: { header: string; value: string; issue: string }[];
        score: number;
        grade: string;
    };
}

interface ScanOptions {
    timeout?: number;
    followRedirects?: boolean;
}

/**
 * Run security headers analysis
 */
export async function run(
    target: string,
    options: ScanOptions = {}
): Promise<HeadersScanResult> {
    const startTime = Date.now();
    
    // Parse target URL
    let targetUrl: URL;
    try {
        targetUrl = new URL(target);
    } catch {
        try {
            targetUrl = new URL(`https://${target}`);
        } catch {
            return {
                success: false,
                module: 'headers_analyzer',
                target,
                data: {
                    url: target,
                    statusCode: 0,
                    headers: {},
                    securityHeaders: [],
                    missingRequired: [],
                    informationDisclosure: [],
                    score: 0,
                    grade: 'F'
                },
                error: 'Invalid target URL',
                duration: Date.now() - startTime
            };
        }
    }
    
    const result: HeadersScanResult = {
        success: true,
        module: 'headers_analyzer',
        target,
        data: {
            url: targetUrl.toString(),
            statusCode: 0,
            headers: {},
            securityHeaders: [],
            missingRequired: [],
            informationDisclosure: [],
            score: 0,
            grade: 'F'
        },
        vulnerabilities: [],
        duration: 0
    };
    
    const timeout = options.timeout || 10000;
    
    // Fetch headers
    const response = await fetchHeaders(targetUrl, timeout, options.followRedirects);
    
    if (!response.success) {
        result.error = response.error || 'Failed to fetch headers';
        result.success = false;
        result.duration = Date.now() - startTime;
        return result;
    }
    
    result.data.statusCode = response.statusCode;
    result.data.headers = response.headers;
    result.data.url = response.finalUrl || targetUrl.toString();
    
    // Analyze security headers
    let score = 0;
    let maxScore = 0;
    
    for (const [headerName, config] of Object.entries(SECURITY_HEADERS)) {
        const headerKey = Object.keys(response.headers).find(
            h => h.toLowerCase() === headerName.toLowerCase()
        );
        const headerValue = headerKey ? response.headers[headerKey] : null;
        
        const headerInfo: HeaderInfo = {
            name: headerName,
            value: headerValue,
            present: !!headerValue,
            required: config.required,
            issues: [],
            recommendation: config.recommendation
        };
        
        // Calculate score weight
        const weight = config.required ? 15 : 5;
        maxScore += weight;
        
        if (headerValue) {
            // Validate the header value
            headerInfo.issues = config.validate(headerValue);
            
            if (headerInfo.issues.length === 0) {
                score += weight;
            } else {
                score += weight * 0.5; // Partial credit for present but misconfigured
            }
        } else if (config.required) {
            result.data.missingRequired.push(headerName);
            
            // Add vulnerability for missing required header
            result.vulnerabilities!.push({
                id: `HDR-${headerName.toUpperCase().replace(/-/g, '')}`,
                name: `Missing ${headerName} Header`,
                severity: config.severity,
                description: `${config.description}. Header is not present.`,
                remediation: config.recommendation,
                host: targetUrl.hostname,
                port: parseInt(targetUrl.port) || (targetUrl.protocol === 'https:' ? 443 : 80),
                service: targetUrl.protocol.replace(':', '')
            });
        }
        
        result.data.securityHeaders.push(headerInfo);
    }
    
    // Check for information disclosure headers
    for (const [headerName, config] of Object.entries(DANGEROUS_HEADERS)) {
        const headerKey = Object.keys(response.headers).find(
            h => h.toLowerCase() === headerName.toLowerCase()
        );
        
        if (headerKey) {
            const value = response.headers[headerKey];
            const issue = config.check(value);
            
            if (issue) {
                result.data.informationDisclosure.push({
                    header: headerName,
                    value,
                    issue
                });
                
                result.vulnerabilities!.push({
                    id: `HDR-INFO-${headerName.toUpperCase().replace(/-/g, '')}`,
                    name: config.description,
                    severity: config.severity,
                    description: issue,
                    remediation: `Remove or obfuscate the ${headerName} header`,
                    host: targetUrl.hostname,
                    port: parseInt(targetUrl.port) || (targetUrl.protocol === 'https:' ? 443 : 80),
                    service: targetUrl.protocol.replace(':', '')
                });
            }
        }
    }
    
    // Check for cookie security
    const setCookie = response.headers['set-cookie'];
    if (setCookie) {
        analyzeCookies(setCookie, targetUrl, result);
    }
    
    // Calculate final score and grade
    result.data.score = Math.round((score / maxScore) * 100);
    result.data.grade = calculateGrade(result.data.score);
    
    // Add summary vulnerability if grade is poor
    if (result.data.grade === 'F' || result.data.grade === 'D') {
        result.vulnerabilities!.unshift({
            id: 'HDR-SUMMARY',
            name: 'Poor Security Headers Configuration',
            severity: 'high',
            description: `Security headers score: ${result.data.score}/100 (Grade: ${result.data.grade}). ${result.data.missingRequired.length} required headers missing.`,
            remediation: 'Implement missing security headers to improve protection against common web attacks.',
            host: targetUrl.hostname,
            port: parseInt(targetUrl.port) || (targetUrl.protocol === 'https:' ? 443 : 80),
            service: targetUrl.protocol.replace(':', '')
        });
    }
    
    result.duration = Date.now() - startTime;
    return result;
}

/**
 * Fetch headers from URL
 */
async function fetchHeaders(
    url: URL,
    timeout: number,
    followRedirects?: boolean,
    redirectCount: number = 0
): Promise<{
    success: boolean;
    statusCode: number;
    headers: { [key: string]: string };
    finalUrl?: string;
    error?: string;
}> {
    return new Promise((resolve) => {
        const isSSL = url.protocol === 'https:';
        
        const options = {
            hostname: url.hostname,
            port: url.port || (isSSL ? 443 : 80),
            path: url.pathname + url.search,
            method: 'GET',
            timeout,
            rejectUnauthorized: false,
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) STRIX-Scanner/1.0',
                'Accept': 'text/html,application/xhtml+xml,*/*'
            }
        };
        
        const protocol = isSSL ? https : http;
        
        const req = protocol.request(options, (res) => {
            // Convert headers to simple object
            const headers: { [key: string]: string } = {};
            for (const [key, value] of Object.entries(res.headers)) {
                if (typeof value === 'string') {
                    headers[key] = value;
                } else if (Array.isArray(value)) {
                    headers[key] = value.join(', ');
                }
            }
            
            // Handle redirects
            if (followRedirects !== false && 
                [301, 302, 303, 307, 308].includes(res.statusCode || 0) &&
                res.headers.location &&
                redirectCount < 5) {
                
                try {
                    const redirectUrl = new URL(res.headers.location, url);
                    res.destroy();
                    
                    fetchHeaders(redirectUrl, timeout, followRedirects, redirectCount + 1)
                        .then(resolve);
                    return;
                } catch {
                    // Invalid redirect URL, return current response
                }
            }
            
            // Consume response body (required)
            res.on('data', () => {});
            res.on('end', () => {
                resolve({
                    success: true,
                    statusCode: res.statusCode || 0,
                    headers,
                    finalUrl: url.toString()
                });
            });
        });
        
        req.on('timeout', () => {
            req.destroy();
            resolve({ success: false, statusCode: 0, headers: {}, error: 'Request timeout' });
        });
        
        req.on('error', (err) => {
            resolve({ success: false, statusCode: 0, headers: {}, error: err.message });
        });
        
        req.end();
    });
}

/**
 * Analyze cookie security attributes
 */
function analyzeCookies(setCookie: string, url: URL, result: HeadersScanResult): void {
    const cookies = setCookie.split(',').map(c => c.trim());
    const isHTTPS = url.protocol === 'https:';
    
    for (const cookie of cookies) {
        const parts = cookie.split(';').map(p => p.trim().toLowerCase());
        const cookieName = cookie.split('=')[0].trim();
        
        const hasSecure = parts.some(p => p === 'secure');
        const hasHttpOnly = parts.some(p => p === 'httponly');
        const hasSameSite = parts.some(p => p.startsWith('samesite='));
        const sameSiteValue = parts.find(p => p.startsWith('samesite='))?.split('=')[1];
        
        if (isHTTPS && !hasSecure) {
            result.vulnerabilities!.push({
                id: 'COOKIE-SECURE',
                name: 'Cookie Missing Secure Flag',
                severity: 'medium',
                description: `Cookie "${cookieName}" is missing the Secure flag`,
                remediation: 'Add Secure flag to cookies to prevent transmission over HTTP',
                host: url.hostname,
                port: parseInt(url.port) || 443,
                service: 'https'
            });
        }
        
        if (!hasHttpOnly) {
            result.vulnerabilities!.push({
                id: 'COOKIE-HTTPONLY',
                name: 'Cookie Missing HttpOnly Flag',
                severity: 'medium',
                description: `Cookie "${cookieName}" is missing the HttpOnly flag`,
                remediation: 'Add HttpOnly flag to prevent client-side JavaScript access',
                host: url.hostname,
                port: parseInt(url.port) || (isHTTPS ? 443 : 80),
                service: url.protocol.replace(':', '')
            });
        }
        
        if (!hasSameSite || sameSiteValue === 'none') {
            result.vulnerabilities!.push({
                id: 'COOKIE-SAMESITE',
                name: 'Cookie Missing/Weak SameSite Attribute',
                severity: 'low',
                description: `Cookie "${cookieName}" has weak or missing SameSite attribute`,
                remediation: 'Set SameSite=Strict or SameSite=Lax to prevent CSRF attacks',
                host: url.hostname,
                port: parseInt(url.port) || (isHTTPS ? 443 : 80),
                service: url.protocol.replace(':', '')
            });
        }
    }
}

/**
 * Calculate letter grade from score
 */
function calculateGrade(score: number): string {
    if (score >= 90) return 'A';
    if (score >= 80) return 'B';
    if (score >= 70) return 'C';
    if (score >= 60) return 'D';
    return 'F';
}

export { SECURITY_HEADERS, DANGEROUS_HEADERS };
export default { run, moduleInfo, SECURITY_HEADERS, DANGEROUS_HEADERS };
