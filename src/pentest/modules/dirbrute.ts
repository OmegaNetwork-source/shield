// STRIX Directory/File Bruteforcer Module
// Like gobuster/dirbuster - discovers hidden directories and files

import * as http from 'http';
import * as https from 'https';
import { VulnerabilityResult, ModuleInfo, ModuleResult } from '../types';

export const moduleInfo: ModuleInfo = {
    name: 'dir_bruteforce',
    displayName: 'Directory Bruteforcer',
    description: 'Discovers hidden directories and files through wordlist-based enumeration',
    author: 'STRIX',
    version: '1.0.0',
    type: 'scanner',
    targetService: 'http',
    options: [
        { name: 'target', type: 'string', required: true, description: 'Target URL (e.g., http://example.com)' },
        { name: 'wordlist', type: 'select', required: false, default: 'common', description: 'Wordlist to use', choices: ['common', 'medium', 'large', 'api', 'backup'] },
        { name: 'extensions', type: 'string', required: false, default: '', description: 'File extensions to check (comma-separated, e.g., php,html,txt)' },
        { name: 'threads', type: 'number', required: false, default: 10, description: 'Number of concurrent requests' },
        { name: 'timeout', type: 'number', required: false, default: 5000, description: 'Request timeout in ms' },
        { name: 'followRedirects', type: 'boolean', required: false, default: false, description: 'Follow redirects' },
        { name: 'showAll', type: 'boolean', required: false, default: false, description: 'Show all status codes (not just 2xx/3xx)' }
    ]
};

// Common wordlists for directory bruteforcing
const WORDLISTS = {
    common: [
        'admin', 'administrator', 'login', 'wp-admin', 'wp-login', 'dashboard',
        'api', 'v1', 'v2', 'graphql', 'rest', 'swagger', 'docs', 'documentation',
        'backup', 'backups', 'bak', 'old', 'temp', 'tmp', 'cache',
        'config', 'configuration', 'settings', 'setup', 'install',
        'uploads', 'upload', 'files', 'images', 'img', 'assets', 'static',
        'includes', 'include', 'inc', 'lib', 'libs', 'library',
        'js', 'javascript', 'css', 'styles', 'fonts',
        'cgi-bin', 'cgi', 'bin', 'scripts', 'script',
        'test', 'tests', 'testing', 'dev', 'development', 'staging',
        'private', 'public', 'internal', 'external',
        'data', 'database', 'db', 'sql', 'mysql', 'phpmyadmin',
        'logs', 'log', 'error', 'errors', 'debug',
        'user', 'users', 'account', 'accounts', 'profile', 'profiles',
        'portal', 'panel', 'console', 'manager', 'management',
        'server-status', 'server-info', 'status', 'info', 'health', 'healthcheck',
        '.git', '.svn', '.env', '.htaccess', '.htpasswd',
        'robots.txt', 'sitemap.xml', 'crossdomain.xml', 'security.txt',
        'web.config', 'nginx.conf', 'httpd.conf',
        'readme', 'README', 'changelog', 'CHANGELOG', 'license', 'LICENSE',
        'node_modules', 'vendor', 'packages', 'bower_components',
        'wp-content', 'wp-includes', 'wp-json',
        'xmlrpc.php', 'wp-cron.php', 'phpinfo.php', 'info.php',
        'shell', 'cmd', 'command', 'exec', 'execute',
        'secret', 'secrets', 'hidden', 'confidential',
        'download', 'downloads', 'export', 'exports',
        'api-docs', 'swagger-ui', 'redoc', 'openapi'
    ],
    medium: [], // Extended in init
    large: [],  // Extended in init
    api: [
        'api', 'v1', 'v2', 'v3', 'api/v1', 'api/v2', 'api/v3',
        'rest', 'graphql', 'gql', 'query',
        'users', 'user', 'auth', 'login', 'logout', 'register', 'signup',
        'token', 'tokens', 'oauth', 'oauth2', 'jwt',
        'health', 'healthcheck', 'status', 'ping', 'version', 'info',
        'docs', 'documentation', 'swagger', 'openapi', 'redoc',
        'admin', 'dashboard', 'metrics', 'stats', 'analytics',
        'search', 'query', 'filter', 'sort',
        'upload', 'uploads', 'download', 'downloads', 'files', 'file',
        'images', 'image', 'media', 'assets',
        'config', 'configuration', 'settings',
        'webhook', 'webhooks', 'callback', 'callbacks',
        'internal', 'private', 'debug', 'test'
    ],
    backup: [
        'backup', 'backups', 'bak', 'backup.sql', 'backup.zip', 'backup.tar.gz',
        'db.sql', 'database.sql', 'dump.sql', 'mysql.sql',
        'site.zip', 'www.zip', 'html.zip', 'public.zip',
        'old', 'old_site', 'site_old', 'www_old',
        'copy', 'copy1', 'temp', 'tmp', 'test',
        '.bak', '.old', '.orig', '.original', '.save', '.swp',
        '~', '.backup', '.copy',
        'archive', 'archives', 'archived'
    ]
};

// Initialize medium/large wordlists
WORDLISTS.medium = [...WORDLISTS.common, ...WORDLISTS.api, ...WORDLISTS.backup];
WORDLISTS.large = [
    ...WORDLISTS.medium,
    ...Array.from({ length: 100 }, (_, i) => `test${i}`),
    ...Array.from({ length: 100 }, (_, i) => `user${i}`),
    ...Array.from({ length: 100 }, (_, i) => `admin${i}`),
    ...['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
];

export interface DirBruteResult {
    path: string;
    url: string;
    statusCode: number;
    contentLength: number;
    contentType?: string;
    redirectTo?: string;
}

export interface DirBruteScanResult extends ModuleResult {
    data: {
        found: DirBruteResult[];
        scanned: number;
        errors: number;
        interestingFinds: DirBruteResult[];
    };
}

export interface DirBruteOptions {
    wordlist?: 'common' | 'medium' | 'large' | 'api' | 'backup';
    extensions?: string;
    threads?: number;
    timeout?: number;
    followRedirects?: boolean;
    showAll?: boolean;
    onProgress?: (current: number, total: number, found: number) => void;
    customWordlist?: string[];
}

/**
 * Run directory bruteforce scan
 */
export async function run(
    target: string,
    options: DirBruteOptions = {}
): Promise<DirBruteScanResult> {
    const startTime = Date.now();
    const threads = options.threads || 10;
    const timeout = options.timeout || 5000;
    const wordlistName = options.wordlist || 'common';
    const showAll = options.showAll || false;
    
    // Parse target URL
    let baseUrl: URL;
    try {
        baseUrl = new URL(target);
    } catch {
        // Try adding protocol
        try {
            baseUrl = new URL(`http://${target}`);
        } catch {
            return {
                success: false,
                module: 'dir_bruteforce',
                target,
                data: { found: [], scanned: 0, errors: 0, interestingFinds: [] },
                error: 'Invalid target URL',
                duration: Date.now() - startTime
            };
        }
    }
    
    const result: DirBruteScanResult = {
        success: true,
        module: 'dir_bruteforce',
        target,
        data: {
            found: [],
            scanned: 0,
            errors: 0,
            interestingFinds: []
        },
        vulnerabilities: [],
        duration: 0
    };
    
    // Build wordlist with extensions
    const baseWordlist = options.customWordlist || WORDLISTS[wordlistName] || WORDLISTS.common;
    const extensions = options.extensions ? options.extensions.split(',').map(e => e.trim()) : [];
    
    const paths: string[] = [];
    for (const word of baseWordlist) {
        paths.push(word);
        for (const ext of extensions) {
            paths.push(`${word}.${ext}`);
        }
    }
    
    const total = paths.length;
    let scanned = 0;
    let errors = 0;
    
    // Process in batches
    for (let i = 0; i < paths.length; i += threads) {
        const batch = paths.slice(i, i + threads);
        const results = await Promise.all(
            batch.map(path => checkPath(baseUrl, path, timeout, options.followRedirects))
        );
        
        for (const res of results) {
            scanned++;
            if (res === null) {
                errors++;
                continue;
            }
            
            // Filter results based on status code
            const isInteresting = res.statusCode >= 200 && res.statusCode < 400;
            const isForbidden = res.statusCode === 403;
            const isServerError = res.statusCode >= 500;
            
            if (showAll || isInteresting || isForbidden) {
                result.data.found.push(res);
            }
            
            // Track particularly interesting finds
            if (isInteresting) {
                const isHighValue = isHighValuePath(res.path);
                if (isHighValue) {
                    result.data.interestingFinds.push(res);
                }
            }
        }
        
        if (options.onProgress) {
            options.onProgress(scanned, total, result.data.found.length);
        }
    }
    
    result.data.scanned = scanned;
    result.data.errors = errors;
    
    // Generate vulnerabilities for interesting finds
    for (const find of result.data.interestingFinds) {
        const vuln = generateVulnerability(find, baseUrl.host);
        if (vuln) {
            result.vulnerabilities!.push(vuln);
        }
    }
    
    result.duration = Date.now() - startTime;
    return result;
}

/**
 * Check if a path exists
 */
async function checkPath(
    baseUrl: URL,
    path: string,
    timeout: number,
    followRedirects?: boolean
): Promise<DirBruteResult | null> {
    return new Promise((resolve) => {
        const fullUrl = new URL(path, baseUrl);
        const isHttps = fullUrl.protocol === 'https:';
        const port = fullUrl.port || (isHttps ? 443 : 80);
        
        const options = {
            hostname: fullUrl.hostname,
            port,
            path: fullUrl.pathname + fullUrl.search,
            method: 'GET',
            timeout,
            rejectUnauthorized: false,
            headers: {
                'User-Agent': 'Mozilla/5.0 (compatible; STRIX-Scanner/1.0)',
                'Accept': '*/*'
            }
        };
        
        const protocol = isHttps ? https : http;
        
        const req = protocol.request(options, (res) => {
            let contentLength = 0;
            
            res.on('data', (chunk) => {
                contentLength += chunk.length;
            });
            
            res.on('end', () => {
                const result: DirBruteResult = {
                    path: '/' + path,
                    url: fullUrl.toString(),
                    statusCode: res.statusCode || 0,
                    contentLength: parseInt(res.headers['content-length'] || '0', 10) || contentLength,
                    contentType: res.headers['content-type']
                };
                
                if (res.headers.location) {
                    result.redirectTo = res.headers.location;
                }
                
                resolve(result);
            });
        });
        
        req.on('timeout', () => {
            req.destroy();
            resolve(null);
        });
        
        req.on('error', () => {
            resolve(null);
        });
        
        req.end();
    });
}

/**
 * Check if a path is high-value/sensitive
 */
function isHighValuePath(path: string): boolean {
    const highValuePatterns = [
        /admin/i, /login/i, /dashboard/i, /panel/i, /console/i,
        /backup/i, /\.sql/i, /\.zip/i, /\.tar/i, /\.gz/i,
        /config/i, /\.env/i, /\.git/i, /\.svn/i,
        /phpinfo/i, /phpmyadmin/i, /mysql/i,
        /api/i, /swagger/i, /graphql/i,
        /upload/i, /file/i, /download/i,
        /secret/i, /private/i, /internal/i,
        /debug/i, /test/i, /dev/i,
        /\.bak/i, /\.old/i, /\.orig/i,
        /server-status/i, /server-info/i
    ];
    
    return highValuePatterns.some(pattern => pattern.test(path));
}

/**
 * Generate vulnerability for a finding
 */
function generateVulnerability(find: DirBruteResult, host: string): VulnerabilityResult | null {
    const path = find.path.toLowerCase();
    
    // Backup files
    if (/\.(bak|old|orig|backup|sql|zip|tar|gz)$/i.test(path) || /backup/i.test(path)) {
        return {
            id: 'DIR-001',
            name: 'Backup File Exposed',
            severity: 'high',
            description: `Backup or sensitive file found: ${find.path}`,
            evidence: `URL: ${find.url}, Status: ${find.statusCode}`,
            remediation: 'Remove backup files from web-accessible directories or restrict access.',
            host,
            service: 'http'
        };
    }
    
    // Admin panels
    if (/admin|dashboard|panel|console|manager/i.test(path)) {
        return {
            id: 'DIR-002',
            name: 'Admin Panel Exposed',
            severity: 'medium',
            description: `Administrative interface found: ${find.path}`,
            evidence: `URL: ${find.url}, Status: ${find.statusCode}`,
            remediation: 'Restrict access to admin interfaces using IP whitelisting or VPN.',
            host,
            service: 'http'
        };
    }
    
    // Version control
    if (/\.git|\.svn|\.hg/i.test(path)) {
        return {
            id: 'DIR-003',
            name: 'Version Control Directory Exposed',
            severity: 'critical',
            description: `Version control directory found: ${find.path}`,
            evidence: `URL: ${find.url}, Status: ${find.statusCode}`,
            remediation: 'Remove version control directories from production or block access via web server config.',
            host,
            service: 'http'
        };
    }
    
    // Config files
    if (/\.env|config|\.htaccess|\.htpasswd|web\.config/i.test(path)) {
        return {
            id: 'DIR-004',
            name: 'Configuration File Exposed',
            severity: 'high',
            description: `Configuration file found: ${find.path}`,
            evidence: `URL: ${find.url}, Status: ${find.statusCode}`,
            remediation: 'Remove or restrict access to configuration files.',
            host,
            service: 'http'
        };
    }
    
    // Debug/info pages
    if (/phpinfo|server-status|server-info|debug/i.test(path)) {
        return {
            id: 'DIR-005',
            name: 'Debug/Info Page Exposed',
            severity: 'medium',
            description: `Debug or information page found: ${find.path}`,
            evidence: `URL: ${find.url}, Status: ${find.statusCode}`,
            remediation: 'Disable or restrict access to debug and information pages in production.',
            host,
            service: 'http'
        };
    }
    
    // API documentation
    if (/swagger|api-doc|openapi|redoc|graphql/i.test(path)) {
        return {
            id: 'DIR-006',
            name: 'API Documentation Exposed',
            severity: 'low',
            description: `API documentation found: ${find.path}`,
            evidence: `URL: ${find.url}, Status: ${find.statusCode}`,
            remediation: 'Consider restricting access to API documentation in production.',
            host,
            service: 'http'
        };
    }
    
    return null;
}

/**
 * Quick scan with common wordlist
 */
export async function quickScan(target: string, options: DirBruteOptions = {}): Promise<DirBruteScanResult> {
    return run(target, { ...options, wordlist: 'common' });
}

/**
 * API-focused scan
 */
export async function apiScan(target: string, options: DirBruteOptions = {}): Promise<DirBruteScanResult> {
    return run(target, { ...options, wordlist: 'api' });
}

/**
 * Backup file scan
 */
export async function backupScan(target: string, options: DirBruteOptions = {}): Promise<DirBruteScanResult> {
    return run(target, { ...options, wordlist: 'backup' });
}

export default { run, moduleInfo, quickScan, apiScan, backupScan, WORDLISTS };
