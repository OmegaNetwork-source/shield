// STRIX Subdomain Takeover Checker Module
// Detects dangling DNS records that could lead to subdomain takeover

import * as dns from 'dns';
import * as http from 'http';
import * as https from 'https';
import { promisify } from 'util';
import { VulnerabilityResult, ModuleInfo, ModuleResult, ProgressCallback } from '../types';

const dnsResolve = promisify(dns.resolve);
const dnsResolve4 = promisify(dns.resolve4);
const dnsResolveCname = promisify(dns.resolveCname);
const dnsResolveTxt = promisify(dns.resolveTxt);
const dnsResolveNs = promisify(dns.resolveNs);

export const moduleInfo: ModuleInfo = {
    name: 'subdomain_takeover',
    displayName: 'Subdomain Takeover Checker',
    description: 'Detects dangling DNS records vulnerable to subdomain takeover',
    author: 'STRIX',
    version: '1.0.0',
    type: 'vuln_check',
    targetService: 'dns',
    options: [
        { name: 'domain', type: 'string', required: true, description: 'Target domain or subdomain' },
        { name: 'subdomains', type: 'string', required: false, description: 'Comma-separated list of subdomains to check' },
        { name: 'wordlist', type: 'select', required: false, default: 'common', description: 'Subdomain wordlist', choices: ['minimal', 'common', 'large'] },
        { name: 'timeout', type: 'number', required: false, default: 5000, description: 'DNS/HTTP timeout in ms' },
        { name: 'checkHTTP', type: 'boolean', required: false, default: true, description: 'Verify with HTTP requests' }
    ]
};

// Service fingerprints for subdomain takeover detection
const TAKEOVER_FINGERPRINTS: {
    service: string;
    cnames: RegExp[];
    fingerprint: RegExp[];
    severity: 'critical' | 'high' | 'medium';
    canTakeover: boolean;
}[] = [
    {
        service: 'AWS S3',
        cnames: [/\.s3\.amazonaws\.com$/i, /\.s3-.*\.amazonaws\.com$/i, /\.s3\..*\.amazonaws\.com$/i],
        fingerprint: [/NoSuchBucket/i, /The specified bucket does not exist/i],
        severity: 'high',
        canTakeover: true
    },
    {
        service: 'AWS Elastic Beanstalk',
        cnames: [/\.elasticbeanstalk\.com$/i],
        fingerprint: [/NXDOMAIN/i],
        severity: 'high',
        canTakeover: true
    },
    {
        service: 'GitHub Pages',
        cnames: [/\.github\.io$/i, /\.githubusercontent\.com$/i],
        fingerprint: [/There isn't a GitHub Pages site here/i, /404.*GitHub Pages/i],
        severity: 'high',
        canTakeover: true
    },
    {
        service: 'Heroku',
        cnames: [/\.herokuapp\.com$/i, /\.herokussl\.com$/i],
        fingerprint: [/No such app/i, /There's nothing here, yet/i, /herokucdn\.com\/error-pages/i],
        severity: 'high',
        canTakeover: true
    },
    {
        service: 'Azure',
        cnames: [/\.azurewebsites\.net$/i, /\.cloudapp\.net$/i, /\.cloudapp\.azure\.com$/i, 
                 /\.azure-api\.net$/i, /\.azurefd\.net$/i, /\.blob\.core\.windows\.net$/i,
                 /\.azureedge\.net$/i, /\.trafficmanager\.net$/i],
        fingerprint: [/404 Web Site not found/i, /Web App - Pair with/i],
        severity: 'high',
        canTakeover: true
    },
    {
        service: 'Shopify',
        cnames: [/\.myshopify\.com$/i],
        fingerprint: [/Sorry, this shop is currently unavailable/i, /Only one step left/i],
        severity: 'medium',
        canTakeover: true
    },
    {
        service: 'Tumblr',
        cnames: [/\.tumblr\.com$/i],
        fingerprint: [/There's nothing here/i, /Whatever you were looking for doesn't currently exist/i],
        severity: 'medium',
        canTakeover: true
    },
    {
        service: 'WordPress.com',
        cnames: [/\.wordpress\.com$/i],
        fingerprint: [/Do you want to register/i],
        severity: 'medium',
        canTakeover: true
    },
    {
        service: 'Fastly',
        cnames: [/\.fastly\.net$/i, /\.fastlylb\.net$/i],
        fingerprint: [/Fastly error: unknown domain/i],
        severity: 'high',
        canTakeover: true
    },
    {
        service: 'Pantheon',
        cnames: [/\.pantheonsite\.io$/i, /\.pantheon\.io$/i],
        fingerprint: [/The gods are wise/i, /404 error unknown site/i],
        severity: 'medium',
        canTakeover: true
    },
    {
        service: 'Zendesk',
        cnames: [/\.zendesk\.com$/i],
        fingerprint: [/Help Center Closed/i, /This help center no longer exists/i],
        severity: 'medium',
        canTakeover: true
    },
    {
        service: 'Unbounce',
        cnames: [/\.unbounce\.com$/i, /unbouncepages\.com$/i],
        fingerprint: [/The requested URL was not found on this server/i],
        severity: 'medium',
        canTakeover: true
    },
    {
        service: 'Surge.sh',
        cnames: [/\.surge\.sh$/i],
        fingerprint: [/project not found/i],
        severity: 'medium',
        canTakeover: true
    },
    {
        service: 'Bitbucket',
        cnames: [/\.bitbucket\.io$/i],
        fingerprint: [/Repository not found/i],
        severity: 'medium',
        canTakeover: true
    },
    {
        service: 'Intercom',
        cnames: [/\.intercom\.io$/i, /\.intercom\.com$/i],
        fingerprint: [/This page is reserved for artistic dogs/i, /Uh oh\. That page doesn't exist/i],
        severity: 'medium',
        canTakeover: true
    },
    {
        service: 'Ghost',
        cnames: [/\.ghost\.io$/i],
        fingerprint: [/The thing you were looking for is no longer here/i],
        severity: 'medium',
        canTakeover: true
    },
    {
        service: 'Netlify',
        cnames: [/\.netlify\.app$/i, /\.netlify\.com$/i],
        fingerprint: [/Not Found - Request ID/i],
        severity: 'medium',
        canTakeover: false // Usually requires verification
    },
    {
        service: 'Vercel',
        cnames: [/\.vercel\.app$/i, /\.now\.sh$/i],
        fingerprint: [/The deployment could not be found/i],
        severity: 'medium',
        canTakeover: false // Usually requires verification
    },
    {
        service: 'Cloudfront',
        cnames: [/\.cloudfront\.net$/i],
        fingerprint: [/ERROR: The request could not be satisfied/i, /Bad Request/i],
        severity: 'high',
        canTakeover: true
    },
    {
        service: 'Google Cloud Storage',
        cnames: [/\.storage\.googleapis\.com$/i],
        fingerprint: [/NoSuchBucket/i, /The specified bucket does not exist/i],
        severity: 'high',
        canTakeover: true
    }
];

// Common subdomains to check
const SUBDOMAIN_WORDLISTS = {
    minimal: [
        'www', 'mail', 'ftp', 'admin', 'api', 'dev', 'staging', 'test', 'app',
        'blog', 'shop', 'store', 'cdn', 'static', 'assets', 'images', 'img'
    ],
    common: [
        'www', 'mail', 'ftp', 'localhost', 'webmail', 'smtp', 'pop', 'ns1', 'ns2',
        'admin', 'administrator', 'api', 'app', 'apps', 'beta', 'blog', 'cdn',
        'cloud', 'cms', 'cpanel', 'dashboard', 'demo', 'dev', 'development',
        'docs', 'download', 'downloads', 'email', 'files', 'forum', 'forums',
        'git', 'help', 'home', 'host', 'hosting', 'images', 'img', 'imap',
        'info', 'internal', 'intranet', 'jenkins', 'jira', 'jobs', 'ldap',
        'login', 'm', 'mail2', 'main', 'manage', 'manager', 'media', 'mobile',
        'mx', 'mx1', 'mx2', 'mysql', 'new', 'news', 'office', 'old', 'panel',
        'partner', 'partners', 'portal', 'preview', 'prod', 'production',
        'remote', 'repo', 'secure', 'server', 'shop', 'staging', 'static',
        'stats', 'status', 'store', 'support', 'test', 'testing', 'tools',
        'upload', 'uploads', 'vpn', 'web', 'webdisk', 'wiki', 'www2'
    ],
    large: [] as string[]
};

// Initialize large wordlist
SUBDOMAIN_WORDLISTS.large = [
    ...SUBDOMAIN_WORDLISTS.common,
    'a', 'b', 'c', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'ag', 'assets1', 'assets2',
    'auth', 'autodiscover', 'autoconfig', 'aws', 'azure', 'backup', 'backups',
    'billing', 'biz', 'board', 'build', 'business', 'cache', 'calendar', 'call',
    'careers', 'chat', 'checkout', 'client', 'clients', 'code', 'community',
    'company', 'connect', 'console', 'contact', 'content', 'control', 'corp',
    'corporate', 'crm', 'cs', 'css', 'customer', 'customers', 'data', 'database',
    'db', 'db1', 'db2', 'desktop', 'direct', 'directory', 'dl', 'dns', 'dns1',
    'dns2', 'doc', 'document', 'documents', 'domain', 'e', 'ecommerce', 'edit',
    'editor', 'edu', 'education', 'email2', 'en', 'english', 'enterprise',
    'erp', 'event', 'events', 'exchange', 'ext', 'external', 'extranet', 'f',
    'facebook', 'feed', 'feedback', 'file', 'finance', 'firewall', 'ftp1',
    'ftp2', 'g', 'gallery', 'game', 'games', 'gateway', 'gis', 'global', 'go',
    'google', 'gov', 'government', 'gw', 'h', 'health', 'helpdesk', 'hq', 'hr',
    'i', 'id', 'identity', 'im', 'image', 'inside', 'insurance', 'int', 'ip',
    'iptv', 'ir', 'it', 'j', 'java', 'job', 'k', 'kb', 'knowledge', 'l', 'lab',
    'labs', 'lan', 'law', 'learn', 'learning', 'legal', 'lib', 'library', 'link',
    'links', 'linux', 'list', 'lists', 'live', 'local', 'log', 'logs', 'lync',
    'mail1', 'mail3', 'mailgate', 'mailhost', 'mailing', 'mailserver', 'map',
    'maps', 'marketing', 'member', 'members', 'message', 'messages', 'microsoft',
    'mirror', 'monitor', 'monitoring', 'mssql', 'n', 'nagios', 'nas', 'nat',
    'net', 'network', 'newsletter', 'noc', 'node', 'ns', 'ns3', 'ns4', 'ntp',
    'o', 'oa', 'oauth', 'odbc', 'online', 'open', 'ops', 'oracle', 'order',
    'orders', 'origin', 'owa', 'p', 'page', 'pages', 'pay', 'payment', 'payments',
    'pda', 'photo', 'photos', 'pic', 'pics', 'picture', 'pictures', 'platform',
    'plesk', 'pma', 'policy', 'pool', 'pop3', 'portfolio', 'post', 'postgres',
    'press', 'print', 'printer', 'printers', 'privacy', 'private', 'pro',
    'product', 'products', 'profile', 'project', 'projects', 'promo', 'proxy',
    'public', 'q', 'qa', 'query', 'queue', 'r', 'radius', 'raw', 'rdp', 'redirect',
    'register', 'registration', 'relay', 'release', 'report', 'reports', 'research',
    'resources', 'rest', 'root', 'router', 'rss', 's', 's1', 's2', 's3', 'sales',
    'sample', 'sandbox', 'scan', 'search', 'security', 'self', 'seo', 'server1',
    'server2', 'service', 'services', 'share', 'sharepoint', 'shop2', 'shopping',
    'showcase', 'sign', 'signin', 'signup', 'site', 'sites', 'sms', 'social',
    'software', 'solr', 'sp', 'spam', 'splunk', 'sql', 'sqlserver', 'srv', 'ssh',
    'ssl', 'sso', 'staff', 'stage', 'stat', 'storage', 'stream', 'streaming',
    'student', 'students', 'submit', 'survey', 'surveys', 'svn', 'sync', 'sys',
    'sysadmin', 'system', 't', 'team', 'teams', 'tech', 'technology', 'temp',
    'template', 'templates', 'terminal', 'ticket', 'tickets', 'time', 'tool',
    'tracker', 'tracking', 'traffic', 'train', 'training', 'travel', 'ts',
    'tunnel', 'tv', 'u', 'ubuntu', 'unix', 'update', 'updates', 'us', 'user',
    'users', 'v', 'v1', 'v2', 'vault', 'vdi', 'vendor', 'video', 'videos', 'view',
    'virtual', 'vm', 'voip', 'w', 'w3', 'wap', 'wc', 'webadmin', 'webapi',
    'webcam', 'weblog', 'webmaster', 'webmin', 'webserver', 'webservice',
    'website', 'whm', 'win', 'windows', 'wireless', 'work', 'wordpress', 'wp',
    'ws', 'ww', 'www1', 'www3', 'wwww', 'x', 'xml', 'xmpp', 'y', 'z', 'zabbix'
];

export interface DNSResult {
    subdomain: string;
    fqdn: string;
    exists: boolean;
    cname?: string[];
    a?: string[];
    ns?: string[];
    txt?: string[];
    error?: string;
}

export interface TakeoverResult {
    subdomain: string;
    fqdn: string;
    vulnerable: boolean;
    service?: string;
    cname?: string;
    fingerprint?: string;
    severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
    canTakeover: boolean;
}

export interface SubdomainTakeoverScanResult extends ModuleResult {
    data: {
        domain: string;
        subdomainsChecked: number;
        subdomainsFound: DNSResult[];
        takeoverRisks: TakeoverResult[];
        danglingRecords: string[];
    };
}

interface ScanOptions {
    subdomains?: string[];
    wordlist?: 'minimal' | 'common' | 'large';
    timeout?: number;
    checkHTTP?: boolean;
    onProgress?: ProgressCallback;
}

/**
 * Run subdomain takeover scan
 */
export async function run(
    domain: string,
    options: ScanOptions = {}
): Promise<SubdomainTakeoverScanResult> {
    const startTime = Date.now();
    
    // Clean domain
    const cleanDomain = domain.replace(/^https?:\/\//, '').replace(/\/.*$/, '').toLowerCase();
    
    const result: SubdomainTakeoverScanResult = {
        success: true,
        module: 'subdomain_takeover',
        target: cleanDomain,
        data: {
            domain: cleanDomain,
            subdomainsChecked: 0,
            subdomainsFound: [],
            takeoverRisks: [],
            danglingRecords: []
        },
        vulnerabilities: [],
        duration: 0
    };
    
    const timeout = options.timeout || 5000;
    const checkHTTP = options.checkHTTP !== false;
    
    // Get subdomains to check
    let subdomains: string[];
    if (options.subdomains && options.subdomains.length > 0) {
        subdomains = options.subdomains;
    } else {
        const wordlistName = options.wordlist || 'common';
        subdomains = SUBDOMAIN_WORDLISTS[wordlistName];
    }
    
    // Also check the apex domain
    const targets = ['', ...subdomains];
    const total = targets.length;
    let completed = 0;
    
    // Process in batches
    const batchSize = 10;
    
    for (let i = 0; i < targets.length; i += batchSize) {
        const batch = targets.slice(i, i + batchSize);
        
        const batchResults = await Promise.all(
            batch.map(sub => checkSubdomain(sub, cleanDomain, timeout))
        );
        
        for (const dnsResult of batchResults) {
            if (dnsResult.exists) {
                result.data.subdomainsFound.push(dnsResult);
                
                // Check for takeover vulnerability
                if (dnsResult.cname && dnsResult.cname.length > 0) {
                    for (const cname of dnsResult.cname) {
                        const takeoverCheck = await checkTakeover(
                            dnsResult.fqdn,
                            cname,
                            checkHTTP,
                            timeout
                        );
                        
                        if (takeoverCheck.vulnerable) {
                            result.data.takeoverRisks.push(takeoverCheck);
                            
                            result.vulnerabilities!.push({
                                id: 'TAKEOVER-001',
                                name: `Subdomain Takeover - ${takeoverCheck.service}`,
                                severity: takeoverCheck.severity,
                                description: `${dnsResult.fqdn} points to ${cname} which appears to be ${takeoverCheck.canTakeover ? 'claimable' : 'potentially vulnerable'}`,
                                evidence: takeoverCheck.fingerprint || `CNAME: ${cname}`,
                                remediation: 'Remove the dangling DNS record or claim the resource on the third-party service.',
                                host: dnsResult.fqdn,
                                service: 'dns'
                            });
                        }
                    }
                }
            } else if (dnsResult.error === 'NXDOMAIN' && dnsResult.cname) {
                // Dangling CNAME record
                result.data.danglingRecords.push(dnsResult.fqdn);
            }
        }
        
        completed += batch.length;
        result.data.subdomainsChecked = completed;
        
        if (options.onProgress) {
            options.onProgress({
                phase: 'subdomain_takeover',
                current: completed,
                total,
                message: `Checking: ${completed}/${total} (Found: ${result.data.subdomainsFound.length}, Risks: ${result.data.takeoverRisks.length})`
            });
        }
    }
    
    // Add summary if dangling records found
    if (result.data.danglingRecords.length > 0) {
        result.vulnerabilities!.push({
            id: 'TAKEOVER-DANGLING',
            name: 'Dangling DNS Records Found',
            severity: 'medium',
            description: `${result.data.danglingRecords.length} subdomain(s) have dangling DNS records`,
            evidence: result.data.danglingRecords.slice(0, 10).join(', '),
            remediation: 'Review and remove unused DNS records to prevent potential subdomain takeover.',
            host: cleanDomain,
            service: 'dns'
        });
    }
    
    result.duration = Date.now() - startTime;
    return result;
}

/**
 * Check DNS records for a subdomain
 */
async function checkSubdomain(
    subdomain: string,
    domain: string,
    timeout: number
): Promise<DNSResult> {
    const fqdn = subdomain ? `${subdomain}.${domain}` : domain;
    
    const result: DNSResult = {
        subdomain,
        fqdn,
        exists: false
    };
    
    // Set DNS timeout
    dns.setServers(['8.8.8.8', '8.8.4.4', '1.1.1.1']);
    
    try {
        // Try to resolve CNAME first
        try {
            const cnames = await dnsResolveCname(fqdn);
            result.cname = cnames;
            result.exists = true;
        } catch (err: any) {
            if (err.code !== 'ENODATA' && err.code !== 'ENOTFOUND') {
                // Some other error
            }
        }
        
        // Try to resolve A records
        try {
            const addresses = await dnsResolve4(fqdn);
            result.a = addresses;
            result.exists = true;
        } catch (err: any) {
            if (err.code === 'ENOTFOUND' || err.code === 'ENODATA') {
                result.error = 'NXDOMAIN';
            }
        }
        
    } catch (err: any) {
        result.error = err.code || err.message;
    }
    
    return result;
}

/**
 * Check if a CNAME target is vulnerable to takeover
 */
async function checkTakeover(
    fqdn: string,
    cname: string,
    checkHTTP: boolean,
    timeout: number
): Promise<TakeoverResult> {
    const result: TakeoverResult = {
        subdomain: fqdn.split('.')[0],
        fqdn,
        vulnerable: false,
        cname,
        severity: 'info',
        canTakeover: false
    };
    
    // Check against known fingerprints
    for (const fp of TAKEOVER_FINGERPRINTS) {
        const matchesCname = fp.cnames.some(pattern => pattern.test(cname));
        
        if (matchesCname) {
            result.service = fp.service;
            result.severity = fp.severity;
            result.canTakeover = fp.canTakeover;
            
            // Check if the service responds with takeover fingerprint
            if (checkHTTP) {
                const httpCheck = await checkHTTPFingerprint(fqdn, fp.fingerprint, timeout);
                if (httpCheck.matched) {
                    result.vulnerable = true;
                    result.fingerprint = httpCheck.evidence;
                }
            } else {
                // Without HTTP check, mark as potential risk
                result.vulnerable = true;
                result.fingerprint = `CNAME points to ${fp.service}`;
            }
            
            break;
        }
    }
    
    // Check if CNAME target doesn't resolve (dangling)
    if (!result.service) {
        try {
            await dnsResolve4(cname);
        } catch (err: any) {
            if (err.code === 'ENOTFOUND') {
                result.vulnerable = true;
                result.service = 'Unknown (Dangling CNAME)';
                result.severity = 'high';
                result.fingerprint = `CNAME target ${cname} does not resolve`;
                result.canTakeover = true;
            }
        }
    }
    
    return result;
}

/**
 * Check HTTP response for takeover fingerprint
 */
async function checkHTTPFingerprint(
    host: string,
    fingerprints: RegExp[],
    timeout: number
): Promise<{ matched: boolean; evidence?: string }> {
    return new Promise((resolve) => {
        // Try HTTPS first, then HTTP
        const tryProtocol = (ssl: boolean) => {
            const options = {
                hostname: host,
                port: ssl ? 443 : 80,
                path: '/',
                method: 'GET',
                timeout,
                rejectUnauthorized: false,
                headers: {
                    'User-Agent': 'Mozilla/5.0 STRIX-Scanner/1.0',
                    'Host': host
                }
            };
            
            const protocol = ssl ? https : http;
            
            const req = protocol.request(options, (res) => {
                let body = '';
                
                res.on('data', (chunk) => {
                    body += chunk;
                    if (body.length > 50000) {
                        res.destroy();
                    }
                });
                
                res.on('end', () => {
                    // Check fingerprints
                    for (const fp of fingerprints) {
                        const match = body.match(fp);
                        if (match) {
                            resolve({
                                matched: true,
                                evidence: match[0].substring(0, 100)
                            });
                            return;
                        }
                    }
                    
                    // Also check for common error pages
                    if (res.statusCode === 404) {
                        resolve({
                            matched: true,
                            evidence: `HTTP 404 - Service not configured`
                        });
                        return;
                    }
                    
                    resolve({ matched: false });
                });
            });
            
            req.on('timeout', () => {
                req.destroy();
                if (ssl) {
                    // Try HTTP if HTTPS times out
                    tryProtocol(false);
                } else {
                    resolve({ matched: false });
                }
            });
            
            req.on('error', () => {
                if (ssl) {
                    // Try HTTP if HTTPS fails
                    tryProtocol(false);
                } else {
                    resolve({ matched: false });
                }
            });
            
            req.end();
        };
        
        tryProtocol(true);
    });
}

export { TAKEOVER_FINGERPRINTS, SUBDOMAIN_WORDLISTS };
export default { run, moduleInfo, TAKEOVER_FINGERPRINTS, SUBDOMAIN_WORDLISTS };
