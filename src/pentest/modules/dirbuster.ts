// STRIX Directory/File Bruteforcer Module
// Like gobuster/dirbuster - discovers hidden directories and files

import * as http from 'http';
import * as https from 'https';
import { VulnerabilityResult, ModuleInfo, ModuleResult, ProgressCallback } from '../types';

export const moduleInfo: ModuleInfo = {
    name: 'dirbuster',
    displayName: 'Directory Bruteforcer',
    description: 'Discovers hidden directories and files through wordlist-based enumeration',
    author: 'STRIX',
    version: '1.0.0',
    type: 'scanner',
    targetService: 'http',
    options: [
        { name: 'target', type: 'string', required: true, description: 'Target URL (http://example.com)' },
        { name: 'wordlist', type: 'select', required: false, default: 'common', description: 'Wordlist to use', choices: ['small', 'common', 'large', 'custom'] },
        { name: 'extensions', type: 'string', required: false, default: '', description: 'File extensions to check (comma-separated: php,asp,html)' },
        { name: 'threads', type: 'number', required: false, default: 10, description: 'Concurrent threads' },
        { name: 'timeout', type: 'number', required: false, default: 5000, description: 'Request timeout in ms' },
        { name: 'followRedirects', type: 'boolean', required: false, default: false, description: 'Follow redirects' },
        { name: 'statusCodes', type: 'string', required: false, default: '200,201,204,301,302,307,401,403', description: 'Status codes to report' }
    ]
};

// Built-in wordlists
const WORDLISTS = {
    small: [
        'admin', 'login', 'wp-admin', 'administrator', 'dashboard', 'api', 'config',
        'backup', 'test', 'dev', 'staging', 'old', 'new', 'temp', 'tmp', 'uploads',
        'images', 'assets', 'css', 'js', 'scripts', 'static', 'media', 'files',
        'docs', 'documentation', 'help', 'support', 'contact', 'about', 'info'
    ],
    common: [
        // Admin & Authentication
        'admin', 'administrator', 'login', 'signin', 'signup', 'register', 'auth',
        'authentication', 'wp-admin', 'wp-login', 'controlpanel', 'cpanel', 'panel',
        'dashboard', 'manage', 'management', 'console', 'portal', 'user', 'users',
        'account', 'accounts', 'member', 'members', 'profile', 'profiles',
        
        // API & Services
        'api', 'api/v1', 'api/v2', 'rest', 'graphql', 'swagger', 'docs', 'redoc',
        'service', 'services', 'ws', 'websocket', 'socket', 'feed', 'rss', 'atom',
        
        // Configuration & Sensitive
        'config', 'configuration', 'settings', 'setup', 'install', 'env', '.env',
        'web.config', 'wp-config', 'config.php', 'database', 'db', 'sql', 'mysql',
        'phpmyadmin', 'pma', 'adminer', 'phpinfo', 'info', 'server-status',
        
        // Backup & Development
        'backup', 'backups', 'bak', 'old', 'new', 'test', 'testing', 'dev',
        'development', 'stage', 'staging', 'demo', 'beta', 'alpha', 'temp', 'tmp',
        'debug', 'log', 'logs', 'error', 'errors', 'trace',
        
        // Static Assets
        'assets', 'static', 'public', 'resources', 'res', 'media', 'images', 'img',
        'css', 'js', 'javascript', 'scripts', 'fonts', 'icons', 'uploads', 'files',
        'download', 'downloads', 'attachment', 'attachments',
        
        // Content & Pages
        'content', 'contents', 'data', 'page', 'pages', 'post', 'posts', 'blog',
        'news', 'article', 'articles', 'category', 'categories', 'tag', 'tags',
        'archive', 'archives', 'search', 'sitemap', 'robots.txt', 'favicon.ico',
        
        // Common CMS/Framework paths
        'wp-content', 'wp-includes', 'themes', 'plugins', 'modules', 'components',
        'includes', 'include', 'inc', 'lib', 'libs', 'library', 'vendor', 'vendors',
        'node_modules', 'bower_components', 'packages',
        
        // Hidden/System
        '.git', '.svn', '.hg', '.htaccess', '.htpasswd', '.DS_Store', 'Thumbs.db',
        'crossdomain.xml', 'clientaccesspolicy.xml', 'security.txt', '.well-known',
        
        // Other common
        'home', 'index', 'default', 'main', 'root', 'app', 'application', 'src',
        'source', 'bin', 'cgi-bin', 'cgi', 'private', 'secure', 'ssl', 'https',
        'ftp', 'sftp', 'mail', 'email', 'webmail', 'smtp', 'imap', 'pop',
        'shop', 'store', 'cart', 'checkout', 'payment', 'order', 'orders',
        'report', 'reports', 'stats', 'statistics', 'analytics', 'metrics',
        'health', 'healthcheck', 'status', 'ping', 'version', 'v1', 'v2'
    ],
    large: [] as string[] // Would be loaded from file in production
};

// Initialize large wordlist with common + extended
WORDLISTS.large = [
    ...WORDLISTS.common,
    // Extended directories
    'access', 'accesslog', 'account', 'activate', 'activity', 'ad', 'address',
    'adm', 'ajax', 'alert', 'alerts', 'alias', 'all', 'alpha', 'analyst',
    'anchor', 'android', 'anonymous', 'answer', 'answers', 'apache', 'api-docs',
    'apis', 'apidocs', 'app.js', 'apple', 'apply', 'approved', 'apps', 'arch',
    'area', 'areas', 'art', 'article', 'asp', 'aspx', 'asset', 'async', 'atom',
    'audit', 'auth', 'author', 'auto', 'avatar', 'avatars', 'aws', 'b2b', 'b2c',
    'backend', 'balance', 'ban', 'bank', 'banner', 'banners', 'base', 'basket',
    'batch', 'bb', 'bbs', 'beacon', 'benchmark', 'billing', 'bin', 'bitrix',
    'blank', 'block', 'blocked', 'board', 'boards', 'body', 'book', 'bookmark',
    'bot', 'bots', 'bounce', 'box', 'branch', 'brand', 'brands', 'bridge',
    'brief', 'broadcast', 'broken', 'broker', 'browse', 'browser', 'bucket',
    'bug', 'bugs', 'build', 'builder', 'bulk', 'bundle', 'bundles', 'business',
    'buy', 'buyer', 'bypass', 'cache', 'cached', 'calendar', 'call', 'callback',
    'cam', 'camera', 'campaign', 'campaigns', 'cancel', 'captcha', 'capture',
    'card', 'cards', 'career', 'careers', 'carousel', 'case', 'cases', 'cash',
    'catalog', 'catalogs', 'catch', 'cdn', 'center', 'central', 'certificate',
    'certs', 'cf', 'cgi', 'chain', 'challenge', 'change', 'changelog', 'channel',
    'channels', 'char', 'characters', 'charge', 'charity', 'chart', 'charts',
    'chat', 'cheap', 'check', 'checker', 'checks', 'child', 'children', 'choice',
    'choices', 'ci', 'city', 'claim', 'claims', 'class', 'classes', 'classic',
    'clean', 'clear', 'click', 'clicks', 'client', 'clients', 'clipboard', 'clone',
    'close', 'closed', 'cloud', 'cloudflare', 'cluster', 'cms', 'co', 'code',
    'codes', 'coding', 'collection', 'collections', 'color', 'colors', 'column',
    'columns', 'com', 'combo', 'come', 'comment', 'comments', 'commerce', 'commit',
    'common', 'communication', 'communications', 'community', 'company', 'compare',
    'comparison', 'compat', 'compatibility', 'compile', 'compiler', 'complete',
    'completed', 'compliance', 'component', 'compose', 'composer', 'compress',
    'compressed', 'compute', 'computer', 'computers', 'concat', 'concept', 'cond',
    'condition', 'conf', 'conference', 'confirm', 'confirmation', 'conflict',
    'connect', 'connected', 'connection', 'connections', 'connector', 'connectors',
    'constant', 'constants', 'constructor', 'consumer', 'consumers', 'contact-us',
    'container', 'containers', 'context', 'contexts', 'contract', 'contracts',
    'control', 'controller', 'controllers', 'controls', 'conversation', 'convert',
    'converter', 'cookie', 'cookies', 'cool', 'coordinator', 'copy', 'copyright',
    'core', 'corp', 'corporate', 'correct', 'correction', 'cost', 'costs', 'count',
    'counter', 'counters', 'countries', 'country', 'coupon', 'coupons', 'course',
    'courses', 'cover', 'coverage', 'crack', 'create', 'created', 'creation',
    'creator', 'credential', 'credentials', 'credit', 'credits', 'crm', 'cron',
    'cronjob', 'cronjobs', 'cross', 'crowd', 'crypto', 'cs', 'csrf', 'csv',
    'culture', 'currencies', 'currency', 'current', 'cursor', 'custom', 'customer',
    'customers', 'customize', 'cut', 'cv', 'cvs', 'cwd', 'cyber', 'cycle', 'daemon'
];

export interface DirBustResult {
    path: string;
    url: string;
    statusCode: number;
    contentLength: number;
    contentType?: string;
    redirectLocation?: string;
}

export interface DirBustScanResult extends ModuleResult {
    data: {
        found: DirBustResult[];
        scanned: number;
        errors: number;
    };
}

interface ScanOptions {
    wordlist?: 'small' | 'common' | 'large' | 'custom';
    customWordlist?: string[];
    extensions?: string[];
    threads?: number;
    timeout?: number;
    followRedirects?: boolean;
    statusCodes?: number[];
    onProgress?: ProgressCallback;
}

/**
 * Run directory bruteforce scan
 */
export async function run(
    target: string,
    options: ScanOptions = {}
): Promise<DirBustScanResult> {
    const startTime = Date.now();
    
    // Parse target URL
    let baseUrl: URL;
    try {
        baseUrl = new URL(target);
    } catch {
        // Try adding https://
        try {
            baseUrl = new URL(`https://${target}`);
        } catch {
            return {
                success: false,
                module: 'dirbuster',
                target,
                data: { found: [], scanned: 0, errors: 0 },
                error: 'Invalid target URL',
                duration: Date.now() - startTime
            };
        }
    }
    
    const result: DirBustScanResult = {
        success: true,
        module: 'dirbuster',
        target,
        data: {
            found: [],
            scanned: 0,
            errors: 0
        },
        vulnerabilities: [],
        duration: 0
    };
    
    // Get wordlist
    const wordlistName = options.wordlist || 'common';
    let paths: string[] = options.customWordlist || WORDLISTS[wordlistName] || WORDLISTS.common;
    
    // Add extensions if specified
    const extensions = options.extensions || [];
    if (extensions.length > 0) {
        const extendedPaths: string[] = [];
        for (const path of paths) {
            extendedPaths.push(path);
            for (const ext of extensions) {
                extendedPaths.push(`${path}.${ext.replace(/^\./, '')}`);
            }
        }
        paths = extendedPaths;
    }
    
    const threads = options.threads || 10;
    const timeout = options.timeout || 5000;
    const validStatusCodes = options.statusCodes || [200, 201, 204, 301, 302, 307, 401, 403];
    
    const total = paths.length;
    let completed = 0;
    
    // Process in batches
    for (let i = 0; i < paths.length; i += threads) {
        const batch = paths.slice(i, i + threads);
        
        const batchResults = await Promise.all(
            batch.map(path => checkPath(baseUrl, path, timeout, options.followRedirects))
        );
        
        for (const checkResult of batchResults) {
            if (checkResult.error) {
                result.data.errors++;
            } else if (validStatusCodes.includes(checkResult.statusCode)) {
                result.data.found.push(checkResult);
            }
        }
        
        completed += batch.length;
        result.data.scanned = completed;
        
        if (options.onProgress) {
            options.onProgress({
                phase: 'dirbust',
                current: completed,
                total,
                message: `Scanning: ${completed}/${total} paths (Found: ${result.data.found.length})`
            });
        }
    }
    
    // Analyze findings for vulnerabilities
    for (const found of result.data.found) {
        // Check for sensitive files/directories
        if (isSensitivePath(found.path)) {
            result.vulnerabilities!.push({
                id: 'DIR-001',
                name: 'Sensitive Path Exposed',
                severity: getSensitivityLevel(found.path),
                description: `Sensitive path found: ${found.path}`,
                evidence: `URL: ${found.url} (Status: ${found.statusCode})`,
                remediation: 'Restrict access to sensitive paths or remove them from public access.',
                host: baseUrl.hostname,
                port: parseInt(baseUrl.port) || (baseUrl.protocol === 'https:' ? 443 : 80),
                service: baseUrl.protocol.replace(':', '')
            });
        }
        
        // Check for backup files
        if (isBackupFile(found.path)) {
            result.vulnerabilities!.push({
                id: 'DIR-002',
                name: 'Backup File Exposed',
                severity: 'high',
                description: `Backup file accessible: ${found.path}`,
                evidence: `URL: ${found.url}`,
                remediation: 'Remove backup files from web-accessible directories.',
                host: baseUrl.hostname,
                port: parseInt(baseUrl.port) || (baseUrl.protocol === 'https:' ? 443 : 80),
                service: baseUrl.protocol.replace(':', '')
            });
        }
        
        // Check for version control
        if (isVersionControl(found.path)) {
            result.vulnerabilities!.push({
                id: 'DIR-003',
                name: 'Version Control Exposed',
                severity: 'critical',
                description: `Version control directory accessible: ${found.path}`,
                evidence: `URL: ${found.url}`,
                remediation: 'Block access to version control directories (.git, .svn, etc.).',
                host: baseUrl.hostname,
                port: parseInt(baseUrl.port) || (baseUrl.protocol === 'https:' ? 443 : 80),
                service: baseUrl.protocol.replace(':', '')
            });
        }
        
        // Check for admin panels
        if (isAdminPath(found.path)) {
            result.vulnerabilities!.push({
                id: 'DIR-004',
                name: 'Admin Panel Found',
                severity: 'medium',
                description: `Admin panel accessible: ${found.path}`,
                evidence: `URL: ${found.url} (Status: ${found.statusCode})`,
                remediation: 'Restrict admin panel access by IP or additional authentication.',
                host: baseUrl.hostname,
                port: parseInt(baseUrl.port) || (baseUrl.protocol === 'https:' ? 443 : 80),
                service: baseUrl.protocol.replace(':', '')
            });
        }
    }
    
    result.duration = Date.now() - startTime;
    return result;
}

/**
 * Check a single path
 */
async function checkPath(
    baseUrl: URL,
    path: string,
    timeout: number,
    followRedirects?: boolean
): Promise<DirBustResult & { error?: boolean }> {
    return new Promise((resolve) => {
        const fullUrl = new URL(path.startsWith('/') ? path : `/${path}`, baseUrl);
        const isSSL = fullUrl.protocol === 'https:';
        
        const options = {
            hostname: fullUrl.hostname,
            port: fullUrl.port || (isSSL ? 443 : 80),
            path: fullUrl.pathname,
            method: 'GET',
            timeout,
            rejectUnauthorized: false,
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) STRIX-Scanner/1.0',
                'Accept': '*/*'
            }
        };
        
        const protocol = isSSL ? https : http;
        
        const req = protocol.request(options, (res) => {
            let body = '';
            
            res.on('data', (chunk) => {
                body += chunk;
                if (body.length > 1000) {
                    res.destroy();
                }
            });
            
            res.on('end', () => {
                resolve({
                    path: path.startsWith('/') ? path : `/${path}`,
                    url: fullUrl.toString(),
                    statusCode: res.statusCode || 0,
                    contentLength: parseInt(res.headers['content-length'] || '0') || body.length,
                    contentType: res.headers['content-type'],
                    redirectLocation: res.headers.location
                });
            });
        });
        
        req.on('timeout', () => {
            req.destroy();
            resolve({
                path,
                url: fullUrl.toString(),
                statusCode: 0,
                contentLength: 0,
                error: true
            });
        });
        
        req.on('error', () => {
            resolve({
                path,
                url: fullUrl.toString(),
                statusCode: 0,
                contentLength: 0,
                error: true
            });
        });
        
        req.end();
    });
}

// Helper functions
function isSensitivePath(path: string): boolean {
    const sensitive = [
        /config/i, /\.env/i, /\.htaccess/i, /\.htpasswd/i, /web\.config/i,
        /database/i, /backup/i, /dump/i, /sql/i, /\.log$/i, /phpinfo/i,
        /server-status/i, /server-info/i, /\.bak$/i, /\.old$/i, /\.orig$/i
    ];
    return sensitive.some(pattern => pattern.test(path));
}

function getSensitivityLevel(path: string): 'critical' | 'high' | 'medium' | 'low' {
    if (/\.env|config\.(php|js|json|yml|yaml)|database|\.sql|\.dump/i.test(path)) return 'critical';
    if (/backup|\.bak|\.old|admin|phpinfo/i.test(path)) return 'high';
    if (/\.log|debug|test/i.test(path)) return 'medium';
    return 'low';
}

function isBackupFile(path: string): boolean {
    return /\.(bak|backup|old|orig|copy|tmp|temp|swp|save)$/i.test(path) ||
           /backup|\.sql$|\.dump$|\.tar$|\.zip$|\.gz$/i.test(path);
}

function isVersionControl(path: string): boolean {
    return /^\/?\.git|^\/?\.svn|^\/?\.hg|^\/?\.bzr|^\/?CVS/i.test(path);
}

function isAdminPath(path: string): boolean {
    return /admin|administrator|manage|dashboard|panel|console|cpanel|wp-admin/i.test(path);
}

export { WORDLISTS };
export default { run, moduleInfo, WORDLISTS };
