// STRIX Native Port Scanner
// High-performance async TCP port scanner

import * as net from 'net';
import * as dns from 'dns';
import { promisify } from 'util';
import { 
    ScanTarget, 
    PortResult, 
    HostResult, 
    ProgressCallback,
    PORT_SERVICE_MAP,
    SERVICE_SIGNATURES,
    COMMON_PORTS 
} from './types';

const dnsReverse = promisify(dns.reverse);
const dnsLookup = promisify(dns.lookup);

export interface ScanOptions {
    timeout?: number;          // Connection timeout in ms
    concurrency?: number;      // Max concurrent connections
    grabBanner?: boolean;      // Attempt to grab service banner
    bannerTimeout?: number;    // Banner grab timeout
    onProgress?: ProgressCallback;
}

const DEFAULT_OPTIONS: ScanOptions = {
    timeout: 2000,
    concurrency: 100,
    grabBanner: true,
    bannerTimeout: 3000
};

/**
 * Scan a single port on a host
 */
export async function scanPort(
    host: string, 
    port: number, 
    options: ScanOptions = {}
): Promise<PortResult> {
    const opts = { ...DEFAULT_OPTIONS, ...options };
    
    return new Promise((resolve) => {
        const socket = new net.Socket();
        let banner = '';
        let resolved = false;
        
        const cleanup = () => {
            if (!resolved) {
                resolved = true;
                socket.destroy();
            }
        };
        
        // Set timeout
        socket.setTimeout(opts.timeout!);
        
        socket.on('connect', () => {
            const result: PortResult = {
                port,
                state: 'open',
                service: PORT_SERVICE_MAP[port] || 'unknown'
            };
            
            if (opts.grabBanner) {
                // Try to grab banner
                const bannerTimer = setTimeout(() => {
                    if (banner) {
                        result.banner = banner.trim();
                        result.service = detectService(banner, port);
                        result.version = extractVersion(banner);
                    }
                    cleanup();
                    resolve(result);
                }, opts.bannerTimeout);
                
                // Send probe for certain services
                const probe = getServiceProbe(port);
                if (probe) {
                    socket.write(probe);
                }
                
                socket.on('data', (data) => {
                    banner += data.toString();
                    if (banner.length > 512) {
                        clearTimeout(bannerTimer);
                        result.banner = banner.substring(0, 512).trim();
                        result.service = detectService(banner, port);
                        result.version = extractVersion(banner);
                        cleanup();
                        resolve(result);
                    }
                });
            } else {
                cleanup();
                resolve(result);
            }
        });
        
        socket.on('timeout', () => {
            cleanup();
            resolve({ port, state: 'filtered' });
        });
        
        socket.on('error', (err: any) => {
            cleanup();
            if (err.code === 'ECONNREFUSED') {
                resolve({ port, state: 'closed' });
            } else {
                resolve({ port, state: 'filtered' });
            }
        });
        
        socket.connect(port, host);
    });
}

/**
 * Scan multiple ports on a host
 */
export async function scanHost(
    host: string,
    ports: number[],
    options: ScanOptions = {}
): Promise<HostResult> {
    const opts = { ...DEFAULT_OPTIONS, ...options };
    const startTime = Date.now();
    
    // Resolve hostname
    let ip = host;
    let hostname: string | undefined;
    
    try {
        if (!isIP(host)) {
            const result = await dnsLookup(host);
            ip = (result as any).address || result;
            hostname = host;
        } else {
            try {
                const names = await dnsReverse(host);
                hostname = names[0];
            } catch {
                // Reverse DNS failed, that's ok
            }
        }
    } catch {
        // DNS lookup failed, use host as-is
    }
    
    const results: PortResult[] = [];
    const total = ports.length;
    let completed = 0;
    
    // Process ports in batches for concurrency control
    const batchSize = opts.concurrency!;
    
    for (let i = 0; i < ports.length; i += batchSize) {
        const batch = ports.slice(i, i + batchSize);
        const batchResults = await Promise.all(
            batch.map(port => scanPort(ip, port, opts))
        );
        
        results.push(...batchResults);
        completed += batch.length;
        
        if (opts.onProgress) {
            opts.onProgress({
                phase: 'port_scan',
                current: completed,
                total,
                message: `Scanning ports: ${completed}/${total}`
            });
        }
    }
    
    // Filter to only open ports
    const openPorts = results.filter(r => r.state === 'open');
    
    return {
        host,
        ip,
        hostname,
        ports: openPorts,
        vulnerabilities: [],
        scanTime: new Date()
    };
}

/**
 * Quick scan - common ports only
 */
export async function quickScan(
    host: string,
    options: ScanOptions = {}
): Promise<HostResult> {
    return scanHost(host, COMMON_PORTS.top20, options);
}

/**
 * Full scan - top 100 ports
 */
export async function fullScan(
    host: string,
    options: ScanOptions = {}
): Promise<HostResult> {
    return scanHost(host, COMMON_PORTS.top100, options);
}

/**
 * Service-specific scan
 */
export async function serviceScan(
    host: string,
    serviceType: 'web' | 'database' | 'remote' | 'mail' | 'file',
    options: ScanOptions = {}
): Promise<HostResult> {
    return scanHost(host, COMMON_PORTS[serviceType], options);
}

/**
 * Custom range scan
 */
export async function rangeScan(
    host: string,
    startPort: number,
    endPort: number,
    options: ScanOptions = {}
): Promise<HostResult> {
    const ports: number[] = [];
    for (let p = startPort; p <= endPort; p++) {
        ports.push(p);
    }
    return scanHost(host, ports, options);
}

// Helper functions

function isIP(str: string): boolean {
    const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
    const ipv6Regex = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
    return ipv4Regex.test(str) || ipv6Regex.test(str);
}

function detectService(banner: string, port: number): string {
    // Try to match banner against known signatures
    for (const [service, patterns] of Object.entries(SERVICE_SIGNATURES)) {
        for (const pattern of patterns) {
            if (pattern.test(banner)) {
                return service;
            }
        }
    }
    // Fall back to port-based detection
    return PORT_SERVICE_MAP[port] || 'unknown';
}

function extractVersion(banner: string): string | undefined {
    // Common version patterns
    const patterns = [
        /(\d+\.\d+(?:\.\d+)?(?:\.\d+)?)/,  // x.x.x.x
        /version[:\s]+([^\s\r\n]+)/i,
        /v(\d+\.\d+[^\s]*)/i,
        /release[:\s]+([^\s\r\n]+)/i
    ];
    
    for (const pattern of patterns) {
        const match = banner.match(pattern);
        if (match) {
            return match[1];
        }
    }
    return undefined;
}

function getServiceProbe(port: number): Buffer | null {
    // Send appropriate probe based on port
    switch (port) {
        case 80:
        case 8080:
        case 8000:
        case 8008:
            return Buffer.from('GET / HTTP/1.0\r\nHost: localhost\r\n\r\n');
        case 443:
        case 8443:
            return null; // Need TLS, handled separately
        case 21:
            return null; // FTP sends banner automatically
        case 22:
            return null; // SSH sends banner automatically
        case 25:
        case 587:
            return Buffer.from('EHLO test\r\n');
        case 110:
            return null; // POP3 sends banner
        case 143:
            return null; // IMAP sends banner
        default:
            return null;
    }
}

export default {
    scanPort,
    scanHost,
    quickScan,
    fullScan,
    serviceScan,
    rangeScan,
    COMMON_PORTS
};
